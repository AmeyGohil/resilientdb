// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/resdb.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fresdb_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fresdb_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/replica_info.pb.h"
#include "proto/signature_info.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fresdb_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fresdb_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[19]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fresdb_2eproto;
namespace resdb {
class BatchClientRequest;
struct BatchClientRequestDefaultTypeInternal;
extern BatchClientRequestDefaultTypeInternal _BatchClientRequest_default_instance_;
class BatchClientRequest_ClientRequest;
struct BatchClientRequest_ClientRequestDefaultTypeInternal;
extern BatchClientRequest_ClientRequestDefaultTypeInternal _BatchClientRequest_ClientRequest_default_instance_;
class BatchClientResponse;
struct BatchClientResponseDefaultTypeInternal;
extern BatchClientResponseDefaultTypeInternal _BatchClientResponse_default_instance_;
class ClientCertInfo;
struct ClientCertInfoDefaultTypeInternal;
extern ClientCertInfoDefaultTypeInternal _ClientCertInfo_default_instance_;
class ClientCertResponse;
struct ClientCertResponseDefaultTypeInternal;
extern ClientCertResponseDefaultTypeInternal _ClientCertResponse_default_instance_;
class HeartBeatInfo;
struct HeartBeatInfoDefaultTypeInternal;
extern HeartBeatInfoDefaultTypeInternal _HeartBeatInfo_default_instance_;
class NewReplicaRequest;
struct NewReplicaRequestDefaultTypeInternal;
extern NewReplicaRequestDefaultTypeInternal _NewReplicaRequest_default_instance_;
class QueryRequest;
struct QueryRequestDefaultTypeInternal;
extern QueryRequestDefaultTypeInternal _QueryRequest_default_instance_;
class QueryResponse;
struct QueryResponseDefaultTypeInternal;
extern QueryResponseDefaultTypeInternal _QueryResponse_default_instance_;
class RecoveryRequest;
struct RecoveryRequestDefaultTypeInternal;
extern RecoveryRequestDefaultTypeInternal _RecoveryRequest_default_instance_;
class RecoveryResponse;
struct RecoveryResponseDefaultTypeInternal;
extern RecoveryResponseDefaultTypeInternal _RecoveryResponse_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestSet;
struct RequestSetDefaultTypeInternal;
extern RequestSetDefaultTypeInternal _RequestSet_default_instance_;
class RequestWithProof;
struct RequestWithProofDefaultTypeInternal;
extern RequestWithProofDefaultTypeInternal _RequestWithProof_default_instance_;
class RequestWithProof_RequestData;
struct RequestWithProof_RequestDataDefaultTypeInternal;
extern RequestWithProof_RequestDataDefaultTypeInternal _RequestWithProof_RequestData_default_instance_;
class ResDBMessage;
struct ResDBMessageDefaultTypeInternal;
extern ResDBMessageDefaultTypeInternal _ResDBMessage_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseData;
struct ResponseDataDefaultTypeInternal;
extern ResponseDataDefaultTypeInternal _ResponseData_default_instance_;
class SystemInfoRequest;
struct SystemInfoRequestDefaultTypeInternal;
extern SystemInfoRequestDefaultTypeInternal _SystemInfoRequest_default_instance_;
}  // namespace resdb
PROTOBUF_NAMESPACE_OPEN
template<> ::resdb::BatchClientRequest* Arena::CreateMaybeMessage<::resdb::BatchClientRequest>(Arena*);
template<> ::resdb::BatchClientRequest_ClientRequest* Arena::CreateMaybeMessage<::resdb::BatchClientRequest_ClientRequest>(Arena*);
template<> ::resdb::BatchClientResponse* Arena::CreateMaybeMessage<::resdb::BatchClientResponse>(Arena*);
template<> ::resdb::ClientCertInfo* Arena::CreateMaybeMessage<::resdb::ClientCertInfo>(Arena*);
template<> ::resdb::ClientCertResponse* Arena::CreateMaybeMessage<::resdb::ClientCertResponse>(Arena*);
template<> ::resdb::HeartBeatInfo* Arena::CreateMaybeMessage<::resdb::HeartBeatInfo>(Arena*);
template<> ::resdb::NewReplicaRequest* Arena::CreateMaybeMessage<::resdb::NewReplicaRequest>(Arena*);
template<> ::resdb::QueryRequest* Arena::CreateMaybeMessage<::resdb::QueryRequest>(Arena*);
template<> ::resdb::QueryResponse* Arena::CreateMaybeMessage<::resdb::QueryResponse>(Arena*);
template<> ::resdb::RecoveryRequest* Arena::CreateMaybeMessage<::resdb::RecoveryRequest>(Arena*);
template<> ::resdb::RecoveryResponse* Arena::CreateMaybeMessage<::resdb::RecoveryResponse>(Arena*);
template<> ::resdb::Request* Arena::CreateMaybeMessage<::resdb::Request>(Arena*);
template<> ::resdb::RequestSet* Arena::CreateMaybeMessage<::resdb::RequestSet>(Arena*);
template<> ::resdb::RequestWithProof* Arena::CreateMaybeMessage<::resdb::RequestWithProof>(Arena*);
template<> ::resdb::RequestWithProof_RequestData* Arena::CreateMaybeMessage<::resdb::RequestWithProof_RequestData>(Arena*);
template<> ::resdb::ResDBMessage* Arena::CreateMaybeMessage<::resdb::ResDBMessage>(Arena*);
template<> ::resdb::Response* Arena::CreateMaybeMessage<::resdb::Response>(Arena*);
template<> ::resdb::ResponseData* Arena::CreateMaybeMessage<::resdb::ResponseData>(Arena*);
template<> ::resdb::SystemInfoRequest* Arena::CreateMaybeMessage<::resdb::SystemInfoRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace resdb {

enum Request_Type : int {
  Request_Type_TYPE_NONE = 0,
  Request_Type_TYPE_HEART_BEAT = 1,
  Request_Type_TYPE_CLIENT_REQUEST = 2,
  Request_Type_TYPE_PRE_PREPARE = 3,
  Request_Type_TYPE_PREPARE = 4,
  Request_Type_TYPE_COMMIT = 5,
  Request_Type_TYPE_CLIENT_CERT = 6,
  Request_Type_TYPE_RESPONSE = 7,
  Request_Type_TYPE_RECOVERY_DATA = 8,
  Request_Type_TYPE_RECOVERY_DATA_RESP = 9,
  Request_Type_TYPE_CHECKPOINT = 10,
  Request_Type_TYPE_QUERY = 11,
  Request_Type_TYPE_REPLICA_STATE = 12,
  Request_Type_TYPE_NEW_TXNS = 14,
  Request_Type_TYPE_GEO_REQUEST = 15,
  Request_Type_NUM_OF_TYPE = 16,
  Request_Type_Request_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Request_Type_Request_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Request_Type_IsValid(int value);
constexpr Request_Type Request_Type_Type_MIN = Request_Type_TYPE_NONE;
constexpr Request_Type Request_Type_Type_MAX = Request_Type_NUM_OF_TYPE;
constexpr int Request_Type_Type_ARRAYSIZE = Request_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_Type_descriptor();
template<typename T>
inline const std::string& Request_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_Type_descriptor(), enum_t_value);
}
inline bool Request_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Request_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_Type>(
    Request_Type_descriptor(), name, value);
}
enum Response_Result : int {
  Response_Result_OK = 0,
  Response_Result_ERROR = -1,
  Response_Result_Response_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Response_Result_Response_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Response_Result_IsValid(int value);
constexpr Response_Result Response_Result_Result_MIN = Response_Result_ERROR;
constexpr Response_Result Response_Result_Result_MAX = Response_Result_OK;
constexpr int Response_Result_Result_ARRAYSIZE = Response_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Response_Result_descriptor();
template<typename T>
inline const std::string& Response_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Response_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Response_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Response_Result_descriptor(), enum_t_value);
}
inline bool Response_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Response_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Response_Result>(
    Response_Result_descriptor(), name, value);
}
enum SystemInfoRequest_Type : int {
  SystemInfoRequest_Type_NONE = 0,
  SystemInfoRequest_Type_ADD_REPLICA = 1,
  SystemInfoRequest_Type_SystemInfoRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SystemInfoRequest_Type_SystemInfoRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SystemInfoRequest_Type_IsValid(int value);
constexpr SystemInfoRequest_Type SystemInfoRequest_Type_Type_MIN = SystemInfoRequest_Type_NONE;
constexpr SystemInfoRequest_Type SystemInfoRequest_Type_Type_MAX = SystemInfoRequest_Type_ADD_REPLICA;
constexpr int SystemInfoRequest_Type_Type_ARRAYSIZE = SystemInfoRequest_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SystemInfoRequest_Type_descriptor();
template<typename T>
inline const std::string& SystemInfoRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemInfoRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemInfoRequest_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SystemInfoRequest_Type_descriptor(), enum_t_value);
}
inline bool SystemInfoRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemInfoRequest_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SystemInfoRequest_Type>(
    SystemInfoRequest_Type_descriptor(), name, value);
}
// ===================================================================

class ResDBMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.ResDBMessage) */ {
 public:
  inline ResDBMessage() : ResDBMessage(nullptr) {}
  ~ResDBMessage() override;
  explicit constexpr ResDBMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResDBMessage(const ResDBMessage& from);
  ResDBMessage(ResDBMessage&& from) noexcept
    : ResDBMessage() {
    *this = ::std::move(from);
  }

  inline ResDBMessage& operator=(const ResDBMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResDBMessage& operator=(ResDBMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResDBMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResDBMessage* internal_default_instance() {
    return reinterpret_cast<const ResDBMessage*>(
               &_ResDBMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ResDBMessage& a, ResDBMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ResDBMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResDBMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResDBMessage* New() const final {
    return new ResDBMessage();
  }

  ResDBMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResDBMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResDBMessage& from);
  void MergeFrom(const ResDBMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResDBMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.ResDBMessage";
  }
  protected:
  explicit ResDBMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .resdb.SignatureInfo signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const ::resdb::SignatureInfo& signature() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::SignatureInfo* release_signature();
  ::resdb::SignatureInfo* mutable_signature();
  void set_allocated_signature(::resdb::SignatureInfo* signature);
  private:
  const ::resdb::SignatureInfo& _internal_signature() const;
  ::resdb::SignatureInfo* _internal_mutable_signature();
  public:
  void unsafe_arena_set_allocated_signature(
      ::resdb::SignatureInfo* signature);
  ::resdb::SignatureInfo* unsafe_arena_release_signature();

  // @@protoc_insertion_point(class_scope:resdb.ResDBMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::resdb::SignatureInfo* signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit constexpr Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return new Request();
  }

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Request_Type Type;
  static constexpr Type TYPE_NONE =
    Request_Type_TYPE_NONE;
  static constexpr Type TYPE_HEART_BEAT =
    Request_Type_TYPE_HEART_BEAT;
  static constexpr Type TYPE_CLIENT_REQUEST =
    Request_Type_TYPE_CLIENT_REQUEST;
  static constexpr Type TYPE_PRE_PREPARE =
    Request_Type_TYPE_PRE_PREPARE;
  static constexpr Type TYPE_PREPARE =
    Request_Type_TYPE_PREPARE;
  static constexpr Type TYPE_COMMIT =
    Request_Type_TYPE_COMMIT;
  static constexpr Type TYPE_CLIENT_CERT =
    Request_Type_TYPE_CLIENT_CERT;
  static constexpr Type TYPE_RESPONSE =
    Request_Type_TYPE_RESPONSE;
  static constexpr Type TYPE_RECOVERY_DATA =
    Request_Type_TYPE_RECOVERY_DATA;
  static constexpr Type TYPE_RECOVERY_DATA_RESP =
    Request_Type_TYPE_RECOVERY_DATA_RESP;
  static constexpr Type TYPE_CHECKPOINT =
    Request_Type_TYPE_CHECKPOINT;
  static constexpr Type TYPE_QUERY =
    Request_Type_TYPE_QUERY;
  static constexpr Type TYPE_REPLICA_STATE =
    Request_Type_TYPE_REPLICA_STATE;
  static constexpr Type TYPE_NEW_TXNS =
    Request_Type_TYPE_NEW_TXNS;
  static constexpr Type TYPE_GEO_REQUEST =
    Request_Type_TYPE_GEO_REQUEST;
  static constexpr Type NUM_OF_TYPE =
    Request_Type_NUM_OF_TYPE;
  static inline bool Type_IsValid(int value) {
    return Request_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Request_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Request_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Request_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Request_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Request_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Request_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kHashFieldNumber = 6,
    kClientInfoFieldNumber = 3,
    kDataSignatureFieldNumber = 13,
    kRegionInfoFieldNumber = 14,
    kCurrentViewFieldNumber = 4,
    kTypeFieldNumber = 1,
    kSenderIdFieldNumber = 7,
    kSeqFieldNumber = 5,
    kProxyIdFieldNumber = 8,
    kCurrentExecutedSeqFieldNumber = 10,
    kIsSystemRequestFieldNumber = 9,
    kNeedResponseFieldNumber = 11,
    kRetFieldNumber = 12,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bytes hash = 6;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // .resdb.ReplicaInfo client_info = 3;
  bool has_client_info() const;
  private:
  bool _internal_has_client_info() const;
  public:
  void clear_client_info();
  const ::resdb::ReplicaInfo& client_info() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::ReplicaInfo* release_client_info();
  ::resdb::ReplicaInfo* mutable_client_info();
  void set_allocated_client_info(::resdb::ReplicaInfo* client_info);
  private:
  const ::resdb::ReplicaInfo& _internal_client_info() const;
  ::resdb::ReplicaInfo* _internal_mutable_client_info();
  public:
  void unsafe_arena_set_allocated_client_info(
      ::resdb::ReplicaInfo* client_info);
  ::resdb::ReplicaInfo* unsafe_arena_release_client_info();

  // .resdb.SignatureInfo data_signature = 13;
  bool has_data_signature() const;
  private:
  bool _internal_has_data_signature() const;
  public:
  void clear_data_signature();
  const ::resdb::SignatureInfo& data_signature() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::SignatureInfo* release_data_signature();
  ::resdb::SignatureInfo* mutable_data_signature();
  void set_allocated_data_signature(::resdb::SignatureInfo* data_signature);
  private:
  const ::resdb::SignatureInfo& _internal_data_signature() const;
  ::resdb::SignatureInfo* _internal_mutable_data_signature();
  public:
  void unsafe_arena_set_allocated_data_signature(
      ::resdb::SignatureInfo* data_signature);
  ::resdb::SignatureInfo* unsafe_arena_release_data_signature();

  // .resdb.RegionInfo region_info = 14;
  bool has_region_info() const;
  private:
  bool _internal_has_region_info() const;
  public:
  void clear_region_info();
  const ::resdb::RegionInfo& region_info() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::RegionInfo* release_region_info();
  ::resdb::RegionInfo* mutable_region_info();
  void set_allocated_region_info(::resdb::RegionInfo* region_info);
  private:
  const ::resdb::RegionInfo& _internal_region_info() const;
  ::resdb::RegionInfo* _internal_mutable_region_info();
  public:
  void unsafe_arena_set_allocated_region_info(
      ::resdb::RegionInfo* region_info);
  ::resdb::RegionInfo* unsafe_arena_release_region_info();

  // uint64 current_view = 4;
  void clear_current_view();
  ::PROTOBUF_NAMESPACE_ID::uint64 current_view() const;
  void set_current_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_current_view() const;
  void _internal_set_current_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int32 type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 sender_id = 7;
  void clear_sender_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id() const;
  void set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sender_id() const;
  void _internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint64 seq = 5;
  void clear_seq();
  ::PROTOBUF_NAMESPACE_ID::uint64 seq() const;
  void set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_seq() const;
  void _internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int64 proxy_id = 8;
  void clear_proxy_id();
  ::PROTOBUF_NAMESPACE_ID::int64 proxy_id() const;
  void set_proxy_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_proxy_id() const;
  void _internal_set_proxy_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint64 current_executed_seq = 10;
  void clear_current_executed_seq();
  ::PROTOBUF_NAMESPACE_ID::uint64 current_executed_seq() const;
  void set_current_executed_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_current_executed_seq() const;
  void _internal_set_current_executed_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool is_system_request = 9;
  void clear_is_system_request();
  bool is_system_request() const;
  void set_is_system_request(bool value);
  private:
  bool _internal_is_system_request() const;
  void _internal_set_is_system_request(bool value);
  public:

  // bool need_response = 11;
  void clear_need_response();
  bool need_response() const;
  void set_need_response(bool value);
  private:
  bool _internal_need_response() const;
  void _internal_set_need_response(bool value);
  public:

  // int32 ret = 12;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::int32 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ret() const;
  void _internal_set_ret(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::resdb::ReplicaInfo* client_info_;
  ::resdb::SignatureInfo* data_signature_;
  ::resdb::RegionInfo* region_info_;
  ::PROTOBUF_NAMESPACE_ID::uint64 current_view_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 seq_;
  ::PROTOBUF_NAMESPACE_ID::int64 proxy_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 current_executed_seq_;
  bool is_system_request_;
  bool need_response_;
  ::PROTOBUF_NAMESPACE_ID::int32 ret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class ResponseData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.ResponseData) */ {
 public:
  inline ResponseData() : ResponseData(nullptr) {}
  ~ResponseData() override;
  explicit constexpr ResponseData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseData(const ResponseData& from);
  ResponseData(ResponseData&& from) noexcept
    : ResponseData() {
    *this = ::std::move(from);
  }

  inline ResponseData& operator=(const ResponseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseData& operator=(ResponseData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseData* internal_default_instance() {
    return reinterpret_cast<const ResponseData*>(
               &_ResponseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ResponseData& a, ResponseData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseData* New() const final {
    return new ResponseData();
  }

  ResponseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseData& from);
  void MergeFrom(const ResponseData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.ResponseData";
  }
  protected:
  explicit ResponseData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .resdb.SignatureInfo signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const ::resdb::SignatureInfo& signature() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::SignatureInfo* release_signature();
  ::resdb::SignatureInfo* mutable_signature();
  void set_allocated_signature(::resdb::SignatureInfo* signature);
  private:
  const ::resdb::SignatureInfo& _internal_signature() const;
  ::resdb::SignatureInfo* _internal_mutable_signature();
  public:
  void unsafe_arena_set_allocated_signature(
      ::resdb::SignatureInfo* signature);
  ::resdb::SignatureInfo* unsafe_arena_release_signature();

  // @@protoc_insertion_point(class_scope:resdb.ResponseData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::resdb::SignatureInfo* signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit constexpr Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return new Response();
  }

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Response_Result Result;
  static constexpr Result OK =
    Response_Result_OK;
  static constexpr Result ERROR =
    Response_Result_ERROR;
  static inline bool Result_IsValid(int value) {
    return Response_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    Response_Result_Result_MIN;
  static constexpr Result Result_MAX =
    Response_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    Response_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return Response_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return Response_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return Response_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRespFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .resdb.ResponseData resp = 2;
  int resp_size() const;
  private:
  int _internal_resp_size() const;
  public:
  void clear_resp();
  ::resdb::ResponseData* mutable_resp(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::ResponseData >*
      mutable_resp();
  private:
  const ::resdb::ResponseData& _internal_resp(int index) const;
  ::resdb::ResponseData* _internal_add_resp();
  public:
  const ::resdb::ResponseData& resp(int index) const;
  ::resdb::ResponseData* add_resp();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::ResponseData >&
      resp() const;

  // .resdb.Response.Result result = 1;
  void clear_result();
  ::resdb::Response_Result result() const;
  void set_result(::resdb::Response_Result value);
  private:
  ::resdb::Response_Result _internal_result() const;
  void _internal_set_result(::resdb::Response_Result value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::ResponseData > resp_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class BatchClientRequest_ClientRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.BatchClientRequest.ClientRequest) */ {
 public:
  inline BatchClientRequest_ClientRequest() : BatchClientRequest_ClientRequest(nullptr) {}
  ~BatchClientRequest_ClientRequest() override;
  explicit constexpr BatchClientRequest_ClientRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchClientRequest_ClientRequest(const BatchClientRequest_ClientRequest& from);
  BatchClientRequest_ClientRequest(BatchClientRequest_ClientRequest&& from) noexcept
    : BatchClientRequest_ClientRequest() {
    *this = ::std::move(from);
  }

  inline BatchClientRequest_ClientRequest& operator=(const BatchClientRequest_ClientRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchClientRequest_ClientRequest& operator=(BatchClientRequest_ClientRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchClientRequest_ClientRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchClientRequest_ClientRequest* internal_default_instance() {
    return reinterpret_cast<const BatchClientRequest_ClientRequest*>(
               &_BatchClientRequest_ClientRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BatchClientRequest_ClientRequest& a, BatchClientRequest_ClientRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchClientRequest_ClientRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchClientRequest_ClientRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchClientRequest_ClientRequest* New() const final {
    return new BatchClientRequest_ClientRequest();
  }

  BatchClientRequest_ClientRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchClientRequest_ClientRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BatchClientRequest_ClientRequest& from);
  void MergeFrom(const BatchClientRequest_ClientRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchClientRequest_ClientRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.BatchClientRequest.ClientRequest";
  }
  protected:
  explicit BatchClientRequest_ClientRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
    kSignatureFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // .resdb.Request request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::resdb::Request& request() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::Request* release_request();
  ::resdb::Request* mutable_request();
  void set_allocated_request(::resdb::Request* request);
  private:
  const ::resdb::Request& _internal_request() const;
  ::resdb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::resdb::Request* request);
  ::resdb::Request* unsafe_arena_release_request();

  // .resdb.SignatureInfo signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const ::resdb::SignatureInfo& signature() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::SignatureInfo* release_signature();
  ::resdb::SignatureInfo* mutable_signature();
  void set_allocated_signature(::resdb::SignatureInfo* signature);
  private:
  const ::resdb::SignatureInfo& _internal_signature() const;
  ::resdb::SignatureInfo* _internal_mutable_signature();
  public:
  void unsafe_arena_set_allocated_signature(
      ::resdb::SignatureInfo* signature);
  ::resdb::SignatureInfo* unsafe_arena_release_signature();

  // int32 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.BatchClientRequest.ClientRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::resdb::Request* request_;
  ::resdb::SignatureInfo* signature_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class BatchClientRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.BatchClientRequest) */ {
 public:
  inline BatchClientRequest() : BatchClientRequest(nullptr) {}
  ~BatchClientRequest() override;
  explicit constexpr BatchClientRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchClientRequest(const BatchClientRequest& from);
  BatchClientRequest(BatchClientRequest&& from) noexcept
    : BatchClientRequest() {
    *this = ::std::move(from);
  }

  inline BatchClientRequest& operator=(const BatchClientRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchClientRequest& operator=(BatchClientRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchClientRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchClientRequest* internal_default_instance() {
    return reinterpret_cast<const BatchClientRequest*>(
               &_BatchClientRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BatchClientRequest& a, BatchClientRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchClientRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchClientRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchClientRequest* New() const final {
    return new BatchClientRequest();
  }

  BatchClientRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchClientRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BatchClientRequest& from);
  void MergeFrom(const BatchClientRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchClientRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.BatchClientRequest";
  }
  protected:
  explicit BatchClientRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BatchClientRequest_ClientRequest ClientRequest;

  // accessors -------------------------------------------------------

  enum : int {
    kClientRequestsFieldNumber = 1,
    kCreatetimeFieldNumber = 2,
    kLocalIdFieldNumber = 3,
  };
  // repeated .resdb.BatchClientRequest.ClientRequest client_requests = 1;
  int client_requests_size() const;
  private:
  int _internal_client_requests_size() const;
  public:
  void clear_client_requests();
  ::resdb::BatchClientRequest_ClientRequest* mutable_client_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::BatchClientRequest_ClientRequest >*
      mutable_client_requests();
  private:
  const ::resdb::BatchClientRequest_ClientRequest& _internal_client_requests(int index) const;
  ::resdb::BatchClientRequest_ClientRequest* _internal_add_client_requests();
  public:
  const ::resdb::BatchClientRequest_ClientRequest& client_requests(int index) const;
  ::resdb::BatchClientRequest_ClientRequest* add_client_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::BatchClientRequest_ClientRequest >&
      client_requests() const;

  // uint64 createtime = 2;
  void clear_createtime();
  ::PROTOBUF_NAMESPACE_ID::uint64 createtime() const;
  void set_createtime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_createtime() const;
  void _internal_set_createtime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 local_id = 3;
  void clear_local_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 local_id() const;
  void set_local_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_local_id() const;
  void _internal_set_local_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.BatchClientRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::BatchClientRequest_ClientRequest > client_requests_;
  ::PROTOBUF_NAMESPACE_ID::uint64 createtime_;
  ::PROTOBUF_NAMESPACE_ID::uint64 local_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class BatchClientResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.BatchClientResponse) */ {
 public:
  inline BatchClientResponse() : BatchClientResponse(nullptr) {}
  ~BatchClientResponse() override;
  explicit constexpr BatchClientResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchClientResponse(const BatchClientResponse& from);
  BatchClientResponse(BatchClientResponse&& from) noexcept
    : BatchClientResponse() {
    *this = ::std::move(from);
  }

  inline BatchClientResponse& operator=(const BatchClientResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchClientResponse& operator=(BatchClientResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchClientResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchClientResponse* internal_default_instance() {
    return reinterpret_cast<const BatchClientResponse*>(
               &_BatchClientResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BatchClientResponse& a, BatchClientResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchClientResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchClientResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchClientResponse* New() const final {
    return new BatchClientResponse();
  }

  BatchClientResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchClientResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BatchClientResponse& from);
  void MergeFrom(const BatchClientResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchClientResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.BatchClientResponse";
  }
  protected:
  explicit BatchClientResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kSignaturesFieldNumber = 2,
    kSeqFieldNumber = 4,
    kCurrentViewFieldNumber = 5,
    kCreatetimeFieldNumber = 6,
    kLocalIdFieldNumber = 7,
    kProxyIdFieldNumber = 3,
  };
  // repeated bytes response = 1;
  int response_size() const;
  private:
  int _internal_response_size() const;
  public:
  void clear_response();
  const std::string& response(int index) const;
  std::string* mutable_response(int index);
  void set_response(int index, const std::string& value);
  void set_response(int index, std::string&& value);
  void set_response(int index, const char* value);
  void set_response(int index, const void* value, size_t size);
  std::string* add_response();
  void add_response(const std::string& value);
  void add_response(std::string&& value);
  void add_response(const char* value);
  void add_response(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& response() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_response();
  private:
  const std::string& _internal_response(int index) const;
  std::string* _internal_add_response();
  public:

  // repeated .resdb.SignatureInfo signatures = 2;
  int signatures_size() const;
  private:
  int _internal_signatures_size() const;
  public:
  void clear_signatures();
  ::resdb::SignatureInfo* mutable_signatures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::SignatureInfo >*
      mutable_signatures();
  private:
  const ::resdb::SignatureInfo& _internal_signatures(int index) const;
  ::resdb::SignatureInfo* _internal_add_signatures();
  public:
  const ::resdb::SignatureInfo& signatures(int index) const;
  ::resdb::SignatureInfo* add_signatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::SignatureInfo >&
      signatures() const;

  // uint64 seq = 4;
  void clear_seq();
  ::PROTOBUF_NAMESPACE_ID::uint64 seq() const;
  void set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_seq() const;
  void _internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 current_view = 5;
  void clear_current_view();
  ::PROTOBUF_NAMESPACE_ID::uint64 current_view() const;
  void set_current_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_current_view() const;
  void _internal_set_current_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 createtime = 6;
  void clear_createtime();
  ::PROTOBUF_NAMESPACE_ID::uint64 createtime() const;
  void set_createtime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_createtime() const;
  void _internal_set_createtime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 local_id = 7;
  void clear_local_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 local_id() const;
  void set_local_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_local_id() const;
  void _internal_set_local_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int32 proxy_id = 3;
  void clear_proxy_id();
  ::PROTOBUF_NAMESPACE_ID::int32 proxy_id() const;
  void set_proxy_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_proxy_id() const;
  void _internal_set_proxy_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.BatchClientResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> response_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::SignatureInfo > signatures_;
  ::PROTOBUF_NAMESPACE_ID::uint64 seq_;
  ::PROTOBUF_NAMESPACE_ID::uint64 current_view_;
  ::PROTOBUF_NAMESPACE_ID::uint64 createtime_;
  ::PROTOBUF_NAMESPACE_ID::uint64 local_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 proxy_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.HeartBeatInfo) */ {
 public:
  inline HeartBeatInfo() : HeartBeatInfo(nullptr) {}
  ~HeartBeatInfo() override;
  explicit constexpr HeartBeatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatInfo(const HeartBeatInfo& from);
  HeartBeatInfo(HeartBeatInfo&& from) noexcept
    : HeartBeatInfo() {
    *this = ::std::move(from);
  }

  inline HeartBeatInfo& operator=(const HeartBeatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatInfo& operator=(HeartBeatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatInfo* internal_default_instance() {
    return reinterpret_cast<const HeartBeatInfo*>(
               &_HeartBeatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HeartBeatInfo& a, HeartBeatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartBeatInfo* New() const final {
    return new HeartBeatInfo();
  }

  HeartBeatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartBeatInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeartBeatInfo& from);
  void MergeFrom(const HeartBeatInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.HeartBeatInfo";
  }
  protected:
  explicit HeartBeatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeysFieldNumber = 1,
  };
  // repeated .resdb.CertificateKey public_keys = 1;
  int public_keys_size() const;
  private:
  int _internal_public_keys_size() const;
  public:
  void clear_public_keys();
  ::resdb::CertificateKey* mutable_public_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::CertificateKey >*
      mutable_public_keys();
  private:
  const ::resdb::CertificateKey& _internal_public_keys(int index) const;
  ::resdb::CertificateKey* _internal_add_public_keys();
  public:
  const ::resdb::CertificateKey& public_keys(int index) const;
  ::resdb::CertificateKey* add_public_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::CertificateKey >&
      public_keys() const;

  // @@protoc_insertion_point(class_scope:resdb.HeartBeatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::CertificateKey > public_keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class ClientCertInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.ClientCertInfo) */ {
 public:
  inline ClientCertInfo() : ClientCertInfo(nullptr) {}
  ~ClientCertInfo() override;
  explicit constexpr ClientCertInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientCertInfo(const ClientCertInfo& from);
  ClientCertInfo(ClientCertInfo&& from) noexcept
    : ClientCertInfo() {
    *this = ::std::move(from);
  }

  inline ClientCertInfo& operator=(const ClientCertInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientCertInfo& operator=(ClientCertInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientCertInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientCertInfo* internal_default_instance() {
    return reinterpret_cast<const ClientCertInfo*>(
               &_ClientCertInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ClientCertInfo& a, ClientCertInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientCertInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientCertInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientCertInfo* New() const final {
    return new ClientCertInfo();
  }

  ClientCertInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientCertInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientCertInfo& from);
  void MergeFrom(const ClientCertInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientCertInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.ClientCertInfo";
  }
  protected:
  explicit ClientCertInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kClientInfoFieldNumber = 2,
  };
  // .resdb.CertificateKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::resdb::CertificateKey& public_key() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::CertificateKey* release_public_key();
  ::resdb::CertificateKey* mutable_public_key();
  void set_allocated_public_key(::resdb::CertificateKey* public_key);
  private:
  const ::resdb::CertificateKey& _internal_public_key() const;
  ::resdb::CertificateKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::resdb::CertificateKey* public_key);
  ::resdb::CertificateKey* unsafe_arena_release_public_key();

  // .resdb.ReplicaInfo client_info = 2;
  bool has_client_info() const;
  private:
  bool _internal_has_client_info() const;
  public:
  void clear_client_info();
  const ::resdb::ReplicaInfo& client_info() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::ReplicaInfo* release_client_info();
  ::resdb::ReplicaInfo* mutable_client_info();
  void set_allocated_client_info(::resdb::ReplicaInfo* client_info);
  private:
  const ::resdb::ReplicaInfo& _internal_client_info() const;
  ::resdb::ReplicaInfo* _internal_mutable_client_info();
  public:
  void unsafe_arena_set_allocated_client_info(
      ::resdb::ReplicaInfo* client_info);
  ::resdb::ReplicaInfo* unsafe_arena_release_client_info();

  // @@protoc_insertion_point(class_scope:resdb.ClientCertInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::resdb::CertificateKey* public_key_;
  ::resdb::ReplicaInfo* client_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class ClientCertResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.ClientCertResponse) */ {
 public:
  inline ClientCertResponse() : ClientCertResponse(nullptr) {}
  ~ClientCertResponse() override;
  explicit constexpr ClientCertResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientCertResponse(const ClientCertResponse& from);
  ClientCertResponse(ClientCertResponse&& from) noexcept
    : ClientCertResponse() {
    *this = ::std::move(from);
  }

  inline ClientCertResponse& operator=(const ClientCertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientCertResponse& operator=(ClientCertResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientCertResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientCertResponse* internal_default_instance() {
    return reinterpret_cast<const ClientCertResponse*>(
               &_ClientCertResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClientCertResponse& a, ClientCertResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientCertResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientCertResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientCertResponse* New() const final {
    return new ClientCertResponse();
  }

  ClientCertResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientCertResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientCertResponse& from);
  void MergeFrom(const ClientCertResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientCertResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.ClientCertResponse";
  }
  protected:
  explicit ClientCertResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeysFieldNumber = 1,
    kReplicasFieldNumber = 2,
  };
  // repeated .resdb.CertificateKey public_keys = 1;
  int public_keys_size() const;
  private:
  int _internal_public_keys_size() const;
  public:
  void clear_public_keys();
  ::resdb::CertificateKey* mutable_public_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::CertificateKey >*
      mutable_public_keys();
  private:
  const ::resdb::CertificateKey& _internal_public_keys(int index) const;
  ::resdb::CertificateKey* _internal_add_public_keys();
  public:
  const ::resdb::CertificateKey& public_keys(int index) const;
  ::resdb::CertificateKey* add_public_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::CertificateKey >&
      public_keys() const;

  // repeated .resdb.ReplicaInfo replicas = 2;
  int replicas_size() const;
  private:
  int _internal_replicas_size() const;
  public:
  void clear_replicas();
  ::resdb::ReplicaInfo* mutable_replicas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::ReplicaInfo >*
      mutable_replicas();
  private:
  const ::resdb::ReplicaInfo& _internal_replicas(int index) const;
  ::resdb::ReplicaInfo* _internal_add_replicas();
  public:
  const ::resdb::ReplicaInfo& replicas(int index) const;
  ::resdb::ReplicaInfo* add_replicas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::ReplicaInfo >&
      replicas() const;

  // @@protoc_insertion_point(class_scope:resdb.ClientCertResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::CertificateKey > public_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::ReplicaInfo > replicas_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class NewReplicaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.NewReplicaRequest) */ {
 public:
  inline NewReplicaRequest() : NewReplicaRequest(nullptr) {}
  ~NewReplicaRequest() override;
  explicit constexpr NewReplicaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewReplicaRequest(const NewReplicaRequest& from);
  NewReplicaRequest(NewReplicaRequest&& from) noexcept
    : NewReplicaRequest() {
    *this = ::std::move(from);
  }

  inline NewReplicaRequest& operator=(const NewReplicaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewReplicaRequest& operator=(NewReplicaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewReplicaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewReplicaRequest* internal_default_instance() {
    return reinterpret_cast<const NewReplicaRequest*>(
               &_NewReplicaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NewReplicaRequest& a, NewReplicaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewReplicaRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewReplicaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewReplicaRequest* New() const final {
    return new NewReplicaRequest();
  }

  NewReplicaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewReplicaRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewReplicaRequest& from);
  void MergeFrom(const NewReplicaRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewReplicaRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.NewReplicaRequest";
  }
  protected:
  explicit NewReplicaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplicaInfoFieldNumber = 1,
  };
  // .resdb.ReplicaInfo replica_info = 1;
  bool has_replica_info() const;
  private:
  bool _internal_has_replica_info() const;
  public:
  void clear_replica_info();
  const ::resdb::ReplicaInfo& replica_info() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::ReplicaInfo* release_replica_info();
  ::resdb::ReplicaInfo* mutable_replica_info();
  void set_allocated_replica_info(::resdb::ReplicaInfo* replica_info);
  private:
  const ::resdb::ReplicaInfo& _internal_replica_info() const;
  ::resdb::ReplicaInfo* _internal_mutable_replica_info();
  public:
  void unsafe_arena_set_allocated_replica_info(
      ::resdb::ReplicaInfo* replica_info);
  ::resdb::ReplicaInfo* unsafe_arena_release_replica_info();

  // @@protoc_insertion_point(class_scope:resdb.NewReplicaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::resdb::ReplicaInfo* replica_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class SystemInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.SystemInfoRequest) */ {
 public:
  inline SystemInfoRequest() : SystemInfoRequest(nullptr) {}
  ~SystemInfoRequest() override;
  explicit constexpr SystemInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemInfoRequest(const SystemInfoRequest& from);
  SystemInfoRequest(SystemInfoRequest&& from) noexcept
    : SystemInfoRequest() {
    *this = ::std::move(from);
  }

  inline SystemInfoRequest& operator=(const SystemInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemInfoRequest& operator=(SystemInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemInfoRequest* internal_default_instance() {
    return reinterpret_cast<const SystemInfoRequest*>(
               &_SystemInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SystemInfoRequest& a, SystemInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemInfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SystemInfoRequest* New() const final {
    return new SystemInfoRequest();
  }

  SystemInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SystemInfoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SystemInfoRequest& from);
  void MergeFrom(const SystemInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemInfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.SystemInfoRequest";
  }
  protected:
  explicit SystemInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SystemInfoRequest_Type Type;
  static constexpr Type NONE =
    SystemInfoRequest_Type_NONE;
  static constexpr Type ADD_REPLICA =
    SystemInfoRequest_Type_ADD_REPLICA;
  static inline bool Type_IsValid(int value) {
    return SystemInfoRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    SystemInfoRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    SystemInfoRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    SystemInfoRequest_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return SystemInfoRequest_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return SystemInfoRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return SystemInfoRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes request = 2;
  void clear_request();
  const std::string& request() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_request();
  void set_allocated_request(std::string* request);
  private:
  const std::string& _internal_request() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request(const std::string& value);
  std::string* _internal_mutable_request();
  public:

  // .resdb.SystemInfoRequest.Type type = 1;
  void clear_type();
  ::resdb::SystemInfoRequest_Type type() const;
  void set_type(::resdb::SystemInfoRequest_Type value);
  private:
  ::resdb::SystemInfoRequest_Type _internal_type() const;
  void _internal_set_type(::resdb::SystemInfoRequest_Type value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.SystemInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class RecoveryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.RecoveryRequest) */ {
 public:
  inline RecoveryRequest() : RecoveryRequest(nullptr) {}
  ~RecoveryRequest() override;
  explicit constexpr RecoveryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecoveryRequest(const RecoveryRequest& from);
  RecoveryRequest(RecoveryRequest&& from) noexcept
    : RecoveryRequest() {
    *this = ::std::move(from);
  }

  inline RecoveryRequest& operator=(const RecoveryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoveryRequest& operator=(RecoveryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecoveryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoveryRequest* internal_default_instance() {
    return reinterpret_cast<const RecoveryRequest*>(
               &_RecoveryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RecoveryRequest& a, RecoveryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecoveryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoveryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecoveryRequest* New() const final {
    return new RecoveryRequest();
  }

  RecoveryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecoveryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecoveryRequest& from);
  void MergeFrom(const RecoveryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecoveryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.RecoveryRequest";
  }
  protected:
  explicit RecoveryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinSeqFieldNumber = 1,
    kMaxSeqFieldNumber = 2,
  };
  // uint64 min_seq = 1;
  void clear_min_seq();
  ::PROTOBUF_NAMESPACE_ID::uint64 min_seq() const;
  void set_min_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_min_seq() const;
  void _internal_set_min_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 max_seq = 2;
  void clear_max_seq();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_seq() const;
  void set_max_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_max_seq() const;
  void _internal_set_max_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.RecoveryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 min_seq_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class RecoveryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.RecoveryResponse) */ {
 public:
  inline RecoveryResponse() : RecoveryResponse(nullptr) {}
  ~RecoveryResponse() override;
  explicit constexpr RecoveryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecoveryResponse(const RecoveryResponse& from);
  RecoveryResponse(RecoveryResponse&& from) noexcept
    : RecoveryResponse() {
    *this = ::std::move(from);
  }

  inline RecoveryResponse& operator=(const RecoveryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoveryResponse& operator=(RecoveryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecoveryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoveryResponse* internal_default_instance() {
    return reinterpret_cast<const RecoveryResponse*>(
               &_RecoveryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RecoveryResponse& a, RecoveryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RecoveryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoveryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecoveryResponse* New() const final {
    return new RecoveryResponse();
  }

  RecoveryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecoveryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecoveryResponse& from);
  void MergeFrom(const RecoveryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecoveryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.RecoveryResponse";
  }
  protected:
  explicit RecoveryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
  };
  // repeated .resdb.Request request = 1;
  int request_size() const;
  private:
  int _internal_request_size() const;
  public:
  void clear_request();
  ::resdb::Request* mutable_request(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::Request >*
      mutable_request();
  private:
  const ::resdb::Request& _internal_request(int index) const;
  ::resdb::Request* _internal_add_request();
  public:
  const ::resdb::Request& request(int index) const;
  ::resdb::Request* add_request();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::Request >&
      request() const;

  // @@protoc_insertion_point(class_scope:resdb.RecoveryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::Request > request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class RequestWithProof_RequestData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.RequestWithProof.RequestData) */ {
 public:
  inline RequestWithProof_RequestData() : RequestWithProof_RequestData(nullptr) {}
  ~RequestWithProof_RequestData() override;
  explicit constexpr RequestWithProof_RequestData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestWithProof_RequestData(const RequestWithProof_RequestData& from);
  RequestWithProof_RequestData(RequestWithProof_RequestData&& from) noexcept
    : RequestWithProof_RequestData() {
    *this = ::std::move(from);
  }

  inline RequestWithProof_RequestData& operator=(const RequestWithProof_RequestData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestWithProof_RequestData& operator=(RequestWithProof_RequestData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestWithProof_RequestData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestWithProof_RequestData* internal_default_instance() {
    return reinterpret_cast<const RequestWithProof_RequestData*>(
               &_RequestWithProof_RequestData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RequestWithProof_RequestData& a, RequestWithProof_RequestData& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestWithProof_RequestData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestWithProof_RequestData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestWithProof_RequestData* New() const final {
    return new RequestWithProof_RequestData();
  }

  RequestWithProof_RequestData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestWithProof_RequestData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestWithProof_RequestData& from);
  void MergeFrom(const RequestWithProof_RequestData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestWithProof_RequestData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.RequestWithProof.RequestData";
  }
  protected:
  explicit RequestWithProof_RequestData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // .resdb.Request request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::resdb::Request& request() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::Request* release_request();
  ::resdb::Request* mutable_request();
  void set_allocated_request(::resdb::Request* request);
  private:
  const ::resdb::Request& _internal_request() const;
  ::resdb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::resdb::Request* request);
  ::resdb::Request* unsafe_arena_release_request();

  // .resdb.SignatureInfo signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const ::resdb::SignatureInfo& signature() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::SignatureInfo* release_signature();
  ::resdb::SignatureInfo* mutable_signature();
  void set_allocated_signature(::resdb::SignatureInfo* signature);
  private:
  const ::resdb::SignatureInfo& _internal_signature() const;
  ::resdb::SignatureInfo* _internal_mutable_signature();
  public:
  void unsafe_arena_set_allocated_signature(
      ::resdb::SignatureInfo* signature);
  ::resdb::SignatureInfo* unsafe_arena_release_signature();

  // @@protoc_insertion_point(class_scope:resdb.RequestWithProof.RequestData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::resdb::Request* request_;
  ::resdb::SignatureInfo* signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class RequestWithProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.RequestWithProof) */ {
 public:
  inline RequestWithProof() : RequestWithProof(nullptr) {}
  ~RequestWithProof() override;
  explicit constexpr RequestWithProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestWithProof(const RequestWithProof& from);
  RequestWithProof(RequestWithProof&& from) noexcept
    : RequestWithProof() {
    *this = ::std::move(from);
  }

  inline RequestWithProof& operator=(const RequestWithProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestWithProof& operator=(RequestWithProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestWithProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestWithProof* internal_default_instance() {
    return reinterpret_cast<const RequestWithProof*>(
               &_RequestWithProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RequestWithProof& a, RequestWithProof& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestWithProof* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestWithProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestWithProof* New() const final {
    return new RequestWithProof();
  }

  RequestWithProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestWithProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestWithProof& from);
  void MergeFrom(const RequestWithProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestWithProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.RequestWithProof";
  }
  protected:
  explicit RequestWithProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RequestWithProof_RequestData RequestData;

  // accessors -------------------------------------------------------

  enum : int {
    kProofsFieldNumber = 2,
    kRequestFieldNumber = 1,
    kSeqFieldNumber = 3,
  };
  // repeated .resdb.RequestWithProof.RequestData proofs = 2;
  int proofs_size() const;
  private:
  int _internal_proofs_size() const;
  public:
  void clear_proofs();
  ::resdb::RequestWithProof_RequestData* mutable_proofs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::RequestWithProof_RequestData >*
      mutable_proofs();
  private:
  const ::resdb::RequestWithProof_RequestData& _internal_proofs(int index) const;
  ::resdb::RequestWithProof_RequestData* _internal_add_proofs();
  public:
  const ::resdb::RequestWithProof_RequestData& proofs(int index) const;
  ::resdb::RequestWithProof_RequestData* add_proofs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::RequestWithProof_RequestData >&
      proofs() const;

  // .resdb.Request request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::resdb::Request& request() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::Request* release_request();
  ::resdb::Request* mutable_request();
  void set_allocated_request(::resdb::Request* request);
  private:
  const ::resdb::Request& _internal_request() const;
  ::resdb::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::resdb::Request* request);
  ::resdb::Request* unsafe_arena_release_request();

  // uint64 seq = 3;
  void clear_seq();
  ::PROTOBUF_NAMESPACE_ID::uint64 seq() const;
  void set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_seq() const;
  void _internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.RequestWithProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::RequestWithProof_RequestData > proofs_;
  ::resdb::Request* request_;
  ::PROTOBUF_NAMESPACE_ID::uint64 seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class RequestSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.RequestSet) */ {
 public:
  inline RequestSet() : RequestSet(nullptr) {}
  ~RequestSet() override;
  explicit constexpr RequestSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestSet(const RequestSet& from);
  RequestSet(RequestSet&& from) noexcept
    : RequestSet() {
    *this = ::std::move(from);
  }

  inline RequestSet& operator=(const RequestSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSet& operator=(RequestSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestSet* internal_default_instance() {
    return reinterpret_cast<const RequestSet*>(
               &_RequestSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RequestSet& a, RequestSet& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSet* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestSet* New() const final {
    return new RequestSet();
  }

  RequestSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestSet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestSet& from);
  void MergeFrom(const RequestSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.RequestSet";
  }
  protected:
  explicit RequestSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .resdb.RequestWithProof requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::resdb::RequestWithProof* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::RequestWithProof >*
      mutable_requests();
  private:
  const ::resdb::RequestWithProof& _internal_requests(int index) const;
  ::resdb::RequestWithProof* _internal_add_requests();
  public:
  const ::resdb::RequestWithProof& requests(int index) const;
  ::resdb::RequestWithProof* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::RequestWithProof >&
      requests() const;

  // @@protoc_insertion_point(class_scope:resdb.RequestSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::RequestWithProof > requests_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class QueryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.QueryRequest) */ {
 public:
  inline QueryRequest() : QueryRequest(nullptr) {}
  ~QueryRequest() override;
  explicit constexpr QueryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRequest(const QueryRequest& from);
  QueryRequest(QueryRequest&& from) noexcept
    : QueryRequest() {
    *this = ::std::move(from);
  }

  inline QueryRequest& operator=(const QueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRequest& operator=(QueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRequest* internal_default_instance() {
    return reinterpret_cast<const QueryRequest*>(
               &_QueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(QueryRequest& a, QueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryRequest* New() const final {
    return new QueryRequest();
  }

  QueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueryRequest& from);
  void MergeFrom(const QueryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.QueryRequest";
  }
  protected:
  explicit QueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinSeqFieldNumber = 1,
    kMaxSeqFieldNumber = 2,
  };
  // uint64 min_seq = 1;
  void clear_min_seq();
  ::PROTOBUF_NAMESPACE_ID::uint64 min_seq() const;
  void set_min_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_min_seq() const;
  void _internal_set_min_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 max_seq = 2;
  void clear_max_seq();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_seq() const;
  void set_max_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_max_seq() const;
  void _internal_set_max_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.QueryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 min_seq_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// -------------------------------------------------------------------

class QueryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.QueryResponse) */ {
 public:
  inline QueryResponse() : QueryResponse(nullptr) {}
  ~QueryResponse() override;
  explicit constexpr QueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryResponse(const QueryResponse& from);
  QueryResponse(QueryResponse&& from) noexcept
    : QueryResponse() {
    *this = ::std::move(from);
  }

  inline QueryResponse& operator=(const QueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryResponse& operator=(QueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryResponse* internal_default_instance() {
    return reinterpret_cast<const QueryResponse*>(
               &_QueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(QueryResponse& a, QueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryResponse* New() const final {
    return new QueryResponse();
  }

  QueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueryResponse& from);
  void MergeFrom(const QueryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.QueryResponse";
  }
  protected:
  explicit QueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 1,
  };
  // repeated .resdb.Request transactions = 1;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  ::resdb::Request* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::Request >*
      mutable_transactions();
  private:
  const ::resdb::Request& _internal_transactions(int index) const;
  ::resdb::Request* _internal_add_transactions();
  public:
  const ::resdb::Request& transactions(int index) const;
  ::resdb::Request* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::Request >&
      transactions() const;

  // @@protoc_insertion_point(class_scope:resdb.QueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::Request > transactions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fresdb_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ResDBMessage

// bytes data = 1;
inline void ResDBMessage::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ResDBMessage::data() const {
  // @@protoc_insertion_point(field_get:resdb.ResDBMessage.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResDBMessage::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resdb.ResDBMessage.data)
}
inline std::string* ResDBMessage::mutable_data() {
  // @@protoc_insertion_point(field_mutable:resdb.ResDBMessage.data)
  return _internal_mutable_data();
}
inline const std::string& ResDBMessage::_internal_data() const {
  return data_.Get();
}
inline void ResDBMessage::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResDBMessage::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResDBMessage::release_data() {
  // @@protoc_insertion_point(field_release:resdb.ResDBMessage.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResDBMessage::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:resdb.ResDBMessage.data)
}

// .resdb.SignatureInfo signature = 2;
inline bool ResDBMessage::_internal_has_signature() const {
  return this != internal_default_instance() && signature_ != nullptr;
}
inline bool ResDBMessage::has_signature() const {
  return _internal_has_signature();
}
inline const ::resdb::SignatureInfo& ResDBMessage::_internal_signature() const {
  const ::resdb::SignatureInfo* p = signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::SignatureInfo&>(
      ::resdb::_SignatureInfo_default_instance_);
}
inline const ::resdb::SignatureInfo& ResDBMessage::signature() const {
  // @@protoc_insertion_point(field_get:resdb.ResDBMessage.signature)
  return _internal_signature();
}
inline void ResDBMessage::unsafe_arena_set_allocated_signature(
    ::resdb::SignatureInfo* signature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature_);
  }
  signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.ResDBMessage.signature)
}
inline ::resdb::SignatureInfo* ResDBMessage::release_signature() {
  
  ::resdb::SignatureInfo* temp = signature_;
  signature_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::SignatureInfo* ResDBMessage::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_release:resdb.ResDBMessage.signature)
  
  ::resdb::SignatureInfo* temp = signature_;
  signature_ = nullptr;
  return temp;
}
inline ::resdb::SignatureInfo* ResDBMessage::_internal_mutable_signature() {
  
  if (signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::SignatureInfo>(GetArenaForAllocation());
    signature_ = p;
  }
  return signature_;
}
inline ::resdb::SignatureInfo* ResDBMessage::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:resdb.ResDBMessage.signature)
  return _internal_mutable_signature();
}
inline void ResDBMessage::set_allocated_signature(::resdb::SignatureInfo* signature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature_);
  }
  if (signature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature));
    if (message_arena != submessage_arena) {
      signature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    
  } else {
    
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:resdb.ResDBMessage.signature)
}

// -------------------------------------------------------------------

// Request

// int32 type = 1;
inline void Request::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::type() const {
  // @@protoc_insertion_point(field_get:resdb.Request.type)
  return _internal_type();
}
inline void Request::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void Request::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:resdb.Request.type)
}

// bytes data = 2;
inline void Request::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Request::data() const {
  // @@protoc_insertion_point(field_get:resdb.Request.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resdb.Request.data)
}
inline std::string* Request::mutable_data() {
  // @@protoc_insertion_point(field_mutable:resdb.Request.data)
  return _internal_mutable_data();
}
inline const std::string& Request::_internal_data() const {
  return data_.Get();
}
inline void Request::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Request::release_data() {
  // @@protoc_insertion_point(field_release:resdb.Request.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Request::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:resdb.Request.data)
}

// .resdb.ReplicaInfo client_info = 3;
inline bool Request::_internal_has_client_info() const {
  return this != internal_default_instance() && client_info_ != nullptr;
}
inline bool Request::has_client_info() const {
  return _internal_has_client_info();
}
inline const ::resdb::ReplicaInfo& Request::_internal_client_info() const {
  const ::resdb::ReplicaInfo* p = client_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::ReplicaInfo&>(
      ::resdb::_ReplicaInfo_default_instance_);
}
inline const ::resdb::ReplicaInfo& Request::client_info() const {
  // @@protoc_insertion_point(field_get:resdb.Request.client_info)
  return _internal_client_info();
}
inline void Request::unsafe_arena_set_allocated_client_info(
    ::resdb::ReplicaInfo* client_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_info_);
  }
  client_info_ = client_info;
  if (client_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.Request.client_info)
}
inline ::resdb::ReplicaInfo* Request::release_client_info() {
  
  ::resdb::ReplicaInfo* temp = client_info_;
  client_info_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::ReplicaInfo* Request::unsafe_arena_release_client_info() {
  // @@protoc_insertion_point(field_release:resdb.Request.client_info)
  
  ::resdb::ReplicaInfo* temp = client_info_;
  client_info_ = nullptr;
  return temp;
}
inline ::resdb::ReplicaInfo* Request::_internal_mutable_client_info() {
  
  if (client_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::ReplicaInfo>(GetArenaForAllocation());
    client_info_ = p;
  }
  return client_info_;
}
inline ::resdb::ReplicaInfo* Request::mutable_client_info() {
  // @@protoc_insertion_point(field_mutable:resdb.Request.client_info)
  return _internal_mutable_client_info();
}
inline void Request::set_allocated_client_info(::resdb::ReplicaInfo* client_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_info_);
  }
  if (client_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_info));
    if (message_arena != submessage_arena) {
      client_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:resdb.Request.client_info)
}

// uint64 current_view = 4;
inline void Request::clear_current_view() {
  current_view_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::_internal_current_view() const {
  return current_view_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::current_view() const {
  // @@protoc_insertion_point(field_get:resdb.Request.current_view)
  return _internal_current_view();
}
inline void Request::_internal_set_current_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  current_view_ = value;
}
inline void Request::set_current_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_current_view(value);
  // @@protoc_insertion_point(field_set:resdb.Request.current_view)
}

// uint64 seq = 5;
inline void Request::clear_seq() {
  seq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::_internal_seq() const {
  return seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::seq() const {
  // @@protoc_insertion_point(field_get:resdb.Request.seq)
  return _internal_seq();
}
inline void Request::_internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  seq_ = value;
}
inline void Request::set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:resdb.Request.seq)
}

// bytes hash = 6;
inline void Request::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& Request::hash() const {
  // @@protoc_insertion_point(field_get:resdb.Request.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resdb.Request.hash)
}
inline std::string* Request::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:resdb.Request.hash)
  return _internal_mutable_hash();
}
inline const std::string& Request::_internal_hash() const {
  return hash_.Get();
}
inline void Request::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Request::release_hash() {
  // @@protoc_insertion_point(field_release:resdb.Request.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Request::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:resdb.Request.hash)
}

// int32 sender_id = 7;
inline void Request::clear_sender_id() {
  sender_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::_internal_sender_id() const {
  return sender_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::sender_id() const {
  // @@protoc_insertion_point(field_get:resdb.Request.sender_id)
  return _internal_sender_id();
}
inline void Request::_internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sender_id_ = value;
}
inline void Request::set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:resdb.Request.sender_id)
}

// int64 proxy_id = 8;
inline void Request::clear_proxy_id() {
  proxy_id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Request::_internal_proxy_id() const {
  return proxy_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Request::proxy_id() const {
  // @@protoc_insertion_point(field_get:resdb.Request.proxy_id)
  return _internal_proxy_id();
}
inline void Request::_internal_set_proxy_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  proxy_id_ = value;
}
inline void Request::set_proxy_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_proxy_id(value);
  // @@protoc_insertion_point(field_set:resdb.Request.proxy_id)
}

// bool is_system_request = 9;
inline void Request::clear_is_system_request() {
  is_system_request_ = false;
}
inline bool Request::_internal_is_system_request() const {
  return is_system_request_;
}
inline bool Request::is_system_request() const {
  // @@protoc_insertion_point(field_get:resdb.Request.is_system_request)
  return _internal_is_system_request();
}
inline void Request::_internal_set_is_system_request(bool value) {
  
  is_system_request_ = value;
}
inline void Request::set_is_system_request(bool value) {
  _internal_set_is_system_request(value);
  // @@protoc_insertion_point(field_set:resdb.Request.is_system_request)
}

// uint64 current_executed_seq = 10;
inline void Request::clear_current_executed_seq() {
  current_executed_seq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::_internal_current_executed_seq() const {
  return current_executed_seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::current_executed_seq() const {
  // @@protoc_insertion_point(field_get:resdb.Request.current_executed_seq)
  return _internal_current_executed_seq();
}
inline void Request::_internal_set_current_executed_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  current_executed_seq_ = value;
}
inline void Request::set_current_executed_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_current_executed_seq(value);
  // @@protoc_insertion_point(field_set:resdb.Request.current_executed_seq)
}

// bool need_response = 11;
inline void Request::clear_need_response() {
  need_response_ = false;
}
inline bool Request::_internal_need_response() const {
  return need_response_;
}
inline bool Request::need_response() const {
  // @@protoc_insertion_point(field_get:resdb.Request.need_response)
  return _internal_need_response();
}
inline void Request::_internal_set_need_response(bool value) {
  
  need_response_ = value;
}
inline void Request::set_need_response(bool value) {
  _internal_set_need_response(value);
  // @@protoc_insertion_point(field_set:resdb.Request.need_response)
}

// int32 ret = 12;
inline void Request::clear_ret() {
  ret_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::_internal_ret() const {
  return ret_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Request::ret() const {
  // @@protoc_insertion_point(field_get:resdb.Request.ret)
  return _internal_ret();
}
inline void Request::_internal_set_ret(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ret_ = value;
}
inline void Request::set_ret(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:resdb.Request.ret)
}

// .resdb.SignatureInfo data_signature = 13;
inline bool Request::_internal_has_data_signature() const {
  return this != internal_default_instance() && data_signature_ != nullptr;
}
inline bool Request::has_data_signature() const {
  return _internal_has_data_signature();
}
inline const ::resdb::SignatureInfo& Request::_internal_data_signature() const {
  const ::resdb::SignatureInfo* p = data_signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::SignatureInfo&>(
      ::resdb::_SignatureInfo_default_instance_);
}
inline const ::resdb::SignatureInfo& Request::data_signature() const {
  // @@protoc_insertion_point(field_get:resdb.Request.data_signature)
  return _internal_data_signature();
}
inline void Request::unsafe_arena_set_allocated_data_signature(
    ::resdb::SignatureInfo* data_signature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_signature_);
  }
  data_signature_ = data_signature;
  if (data_signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.Request.data_signature)
}
inline ::resdb::SignatureInfo* Request::release_data_signature() {
  
  ::resdb::SignatureInfo* temp = data_signature_;
  data_signature_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::SignatureInfo* Request::unsafe_arena_release_data_signature() {
  // @@protoc_insertion_point(field_release:resdb.Request.data_signature)
  
  ::resdb::SignatureInfo* temp = data_signature_;
  data_signature_ = nullptr;
  return temp;
}
inline ::resdb::SignatureInfo* Request::_internal_mutable_data_signature() {
  
  if (data_signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::SignatureInfo>(GetArenaForAllocation());
    data_signature_ = p;
  }
  return data_signature_;
}
inline ::resdb::SignatureInfo* Request::mutable_data_signature() {
  // @@protoc_insertion_point(field_mutable:resdb.Request.data_signature)
  return _internal_mutable_data_signature();
}
inline void Request::set_allocated_data_signature(::resdb::SignatureInfo* data_signature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_signature_);
  }
  if (data_signature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_signature));
    if (message_arena != submessage_arena) {
      data_signature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_signature, submessage_arena);
    }
    
  } else {
    
  }
  data_signature_ = data_signature;
  // @@protoc_insertion_point(field_set_allocated:resdb.Request.data_signature)
}

// .resdb.RegionInfo region_info = 14;
inline bool Request::_internal_has_region_info() const {
  return this != internal_default_instance() && region_info_ != nullptr;
}
inline bool Request::has_region_info() const {
  return _internal_has_region_info();
}
inline const ::resdb::RegionInfo& Request::_internal_region_info() const {
  const ::resdb::RegionInfo* p = region_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::RegionInfo&>(
      ::resdb::_RegionInfo_default_instance_);
}
inline const ::resdb::RegionInfo& Request::region_info() const {
  // @@protoc_insertion_point(field_get:resdb.Request.region_info)
  return _internal_region_info();
}
inline void Request::unsafe_arena_set_allocated_region_info(
    ::resdb::RegionInfo* region_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_info_);
  }
  region_info_ = region_info;
  if (region_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.Request.region_info)
}
inline ::resdb::RegionInfo* Request::release_region_info() {
  
  ::resdb::RegionInfo* temp = region_info_;
  region_info_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::RegionInfo* Request::unsafe_arena_release_region_info() {
  // @@protoc_insertion_point(field_release:resdb.Request.region_info)
  
  ::resdb::RegionInfo* temp = region_info_;
  region_info_ = nullptr;
  return temp;
}
inline ::resdb::RegionInfo* Request::_internal_mutable_region_info() {
  
  if (region_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::RegionInfo>(GetArenaForAllocation());
    region_info_ = p;
  }
  return region_info_;
}
inline ::resdb::RegionInfo* Request::mutable_region_info() {
  // @@protoc_insertion_point(field_mutable:resdb.Request.region_info)
  return _internal_mutable_region_info();
}
inline void Request::set_allocated_region_info(::resdb::RegionInfo* region_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_info_);
  }
  if (region_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_info));
    if (message_arena != submessage_arena) {
      region_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_info, submessage_arena);
    }
    
  } else {
    
  }
  region_info_ = region_info;
  // @@protoc_insertion_point(field_set_allocated:resdb.Request.region_info)
}

// -------------------------------------------------------------------

// ResponseData

// bytes data = 1;
inline void ResponseData::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ResponseData::data() const {
  // @@protoc_insertion_point(field_get:resdb.ResponseData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseData::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resdb.ResponseData.data)
}
inline std::string* ResponseData::mutable_data() {
  // @@protoc_insertion_point(field_mutable:resdb.ResponseData.data)
  return _internal_mutable_data();
}
inline const std::string& ResponseData::_internal_data() const {
  return data_.Get();
}
inline void ResponseData::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseData::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseData::release_data() {
  // @@protoc_insertion_point(field_release:resdb.ResponseData.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:resdb.ResponseData.data)
}

// .resdb.SignatureInfo signature = 2;
inline bool ResponseData::_internal_has_signature() const {
  return this != internal_default_instance() && signature_ != nullptr;
}
inline bool ResponseData::has_signature() const {
  return _internal_has_signature();
}
inline const ::resdb::SignatureInfo& ResponseData::_internal_signature() const {
  const ::resdb::SignatureInfo* p = signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::SignatureInfo&>(
      ::resdb::_SignatureInfo_default_instance_);
}
inline const ::resdb::SignatureInfo& ResponseData::signature() const {
  // @@protoc_insertion_point(field_get:resdb.ResponseData.signature)
  return _internal_signature();
}
inline void ResponseData::unsafe_arena_set_allocated_signature(
    ::resdb::SignatureInfo* signature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature_);
  }
  signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.ResponseData.signature)
}
inline ::resdb::SignatureInfo* ResponseData::release_signature() {
  
  ::resdb::SignatureInfo* temp = signature_;
  signature_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::SignatureInfo* ResponseData::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_release:resdb.ResponseData.signature)
  
  ::resdb::SignatureInfo* temp = signature_;
  signature_ = nullptr;
  return temp;
}
inline ::resdb::SignatureInfo* ResponseData::_internal_mutable_signature() {
  
  if (signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::SignatureInfo>(GetArenaForAllocation());
    signature_ = p;
  }
  return signature_;
}
inline ::resdb::SignatureInfo* ResponseData::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:resdb.ResponseData.signature)
  return _internal_mutable_signature();
}
inline void ResponseData::set_allocated_signature(::resdb::SignatureInfo* signature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature_);
  }
  if (signature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature));
    if (message_arena != submessage_arena) {
      signature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    
  } else {
    
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:resdb.ResponseData.signature)
}

// -------------------------------------------------------------------

// Response

// .resdb.Response.Result result = 1;
inline void Response::clear_result() {
  result_ = 0;
}
inline ::resdb::Response_Result Response::_internal_result() const {
  return static_cast< ::resdb::Response_Result >(result_);
}
inline ::resdb::Response_Result Response::result() const {
  // @@protoc_insertion_point(field_get:resdb.Response.result)
  return _internal_result();
}
inline void Response::_internal_set_result(::resdb::Response_Result value) {
  
  result_ = value;
}
inline void Response::set_result(::resdb::Response_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:resdb.Response.result)
}

// repeated .resdb.ResponseData resp = 2;
inline int Response::_internal_resp_size() const {
  return resp_.size();
}
inline int Response::resp_size() const {
  return _internal_resp_size();
}
inline void Response::clear_resp() {
  resp_.Clear();
}
inline ::resdb::ResponseData* Response::mutable_resp(int index) {
  // @@protoc_insertion_point(field_mutable:resdb.Response.resp)
  return resp_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::ResponseData >*
Response::mutable_resp() {
  // @@protoc_insertion_point(field_mutable_list:resdb.Response.resp)
  return &resp_;
}
inline const ::resdb::ResponseData& Response::_internal_resp(int index) const {
  return resp_.Get(index);
}
inline const ::resdb::ResponseData& Response::resp(int index) const {
  // @@protoc_insertion_point(field_get:resdb.Response.resp)
  return _internal_resp(index);
}
inline ::resdb::ResponseData* Response::_internal_add_resp() {
  return resp_.Add();
}
inline ::resdb::ResponseData* Response::add_resp() {
  // @@protoc_insertion_point(field_add:resdb.Response.resp)
  return _internal_add_resp();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::ResponseData >&
Response::resp() const {
  // @@protoc_insertion_point(field_list:resdb.Response.resp)
  return resp_;
}

// -------------------------------------------------------------------

// BatchClientRequest_ClientRequest

// .resdb.Request request = 1;
inline bool BatchClientRequest_ClientRequest::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool BatchClientRequest_ClientRequest::has_request() const {
  return _internal_has_request();
}
inline void BatchClientRequest_ClientRequest::clear_request() {
  if (GetArenaForAllocation() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::resdb::Request& BatchClientRequest_ClientRequest::_internal_request() const {
  const ::resdb::Request* p = request_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::Request&>(
      ::resdb::_Request_default_instance_);
}
inline const ::resdb::Request& BatchClientRequest_ClientRequest::request() const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientRequest.ClientRequest.request)
  return _internal_request();
}
inline void BatchClientRequest_ClientRequest::unsafe_arena_set_allocated_request(
    ::resdb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.BatchClientRequest.ClientRequest.request)
}
inline ::resdb::Request* BatchClientRequest_ClientRequest::release_request() {
  
  ::resdb::Request* temp = request_;
  request_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::Request* BatchClientRequest_ClientRequest::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:resdb.BatchClientRequest.ClientRequest.request)
  
  ::resdb::Request* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::resdb::Request* BatchClientRequest_ClientRequest::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::Request>(GetArenaForAllocation());
    request_ = p;
  }
  return request_;
}
inline ::resdb::Request* BatchClientRequest_ClientRequest::mutable_request() {
  // @@protoc_insertion_point(field_mutable:resdb.BatchClientRequest.ClientRequest.request)
  return _internal_mutable_request();
}
inline void BatchClientRequest_ClientRequest::set_allocated_request(::resdb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::resdb::Request>::GetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:resdb.BatchClientRequest.ClientRequest.request)
}

// .resdb.SignatureInfo signature = 2;
inline bool BatchClientRequest_ClientRequest::_internal_has_signature() const {
  return this != internal_default_instance() && signature_ != nullptr;
}
inline bool BatchClientRequest_ClientRequest::has_signature() const {
  return _internal_has_signature();
}
inline const ::resdb::SignatureInfo& BatchClientRequest_ClientRequest::_internal_signature() const {
  const ::resdb::SignatureInfo* p = signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::SignatureInfo&>(
      ::resdb::_SignatureInfo_default_instance_);
}
inline const ::resdb::SignatureInfo& BatchClientRequest_ClientRequest::signature() const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientRequest.ClientRequest.signature)
  return _internal_signature();
}
inline void BatchClientRequest_ClientRequest::unsafe_arena_set_allocated_signature(
    ::resdb::SignatureInfo* signature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature_);
  }
  signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.BatchClientRequest.ClientRequest.signature)
}
inline ::resdb::SignatureInfo* BatchClientRequest_ClientRequest::release_signature() {
  
  ::resdb::SignatureInfo* temp = signature_;
  signature_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::SignatureInfo* BatchClientRequest_ClientRequest::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_release:resdb.BatchClientRequest.ClientRequest.signature)
  
  ::resdb::SignatureInfo* temp = signature_;
  signature_ = nullptr;
  return temp;
}
inline ::resdb::SignatureInfo* BatchClientRequest_ClientRequest::_internal_mutable_signature() {
  
  if (signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::SignatureInfo>(GetArenaForAllocation());
    signature_ = p;
  }
  return signature_;
}
inline ::resdb::SignatureInfo* BatchClientRequest_ClientRequest::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:resdb.BatchClientRequest.ClientRequest.signature)
  return _internal_mutable_signature();
}
inline void BatchClientRequest_ClientRequest::set_allocated_signature(::resdb::SignatureInfo* signature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature_);
  }
  if (signature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature));
    if (message_arena != submessage_arena) {
      signature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    
  } else {
    
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:resdb.BatchClientRequest.ClientRequest.signature)
}

// int32 id = 3;
inline void BatchClientRequest_ClientRequest::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatchClientRequest_ClientRequest::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatchClientRequest_ClientRequest::id() const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientRequest.ClientRequest.id)
  return _internal_id();
}
inline void BatchClientRequest_ClientRequest::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void BatchClientRequest_ClientRequest::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:resdb.BatchClientRequest.ClientRequest.id)
}

// -------------------------------------------------------------------

// BatchClientRequest

// repeated .resdb.BatchClientRequest.ClientRequest client_requests = 1;
inline int BatchClientRequest::_internal_client_requests_size() const {
  return client_requests_.size();
}
inline int BatchClientRequest::client_requests_size() const {
  return _internal_client_requests_size();
}
inline void BatchClientRequest::clear_client_requests() {
  client_requests_.Clear();
}
inline ::resdb::BatchClientRequest_ClientRequest* BatchClientRequest::mutable_client_requests(int index) {
  // @@protoc_insertion_point(field_mutable:resdb.BatchClientRequest.client_requests)
  return client_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::BatchClientRequest_ClientRequest >*
BatchClientRequest::mutable_client_requests() {
  // @@protoc_insertion_point(field_mutable_list:resdb.BatchClientRequest.client_requests)
  return &client_requests_;
}
inline const ::resdb::BatchClientRequest_ClientRequest& BatchClientRequest::_internal_client_requests(int index) const {
  return client_requests_.Get(index);
}
inline const ::resdb::BatchClientRequest_ClientRequest& BatchClientRequest::client_requests(int index) const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientRequest.client_requests)
  return _internal_client_requests(index);
}
inline ::resdb::BatchClientRequest_ClientRequest* BatchClientRequest::_internal_add_client_requests() {
  return client_requests_.Add();
}
inline ::resdb::BatchClientRequest_ClientRequest* BatchClientRequest::add_client_requests() {
  // @@protoc_insertion_point(field_add:resdb.BatchClientRequest.client_requests)
  return _internal_add_client_requests();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::BatchClientRequest_ClientRequest >&
BatchClientRequest::client_requests() const {
  // @@protoc_insertion_point(field_list:resdb.BatchClientRequest.client_requests)
  return client_requests_;
}

// uint64 createtime = 2;
inline void BatchClientRequest::clear_createtime() {
  createtime_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientRequest::_internal_createtime() const {
  return createtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientRequest::createtime() const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientRequest.createtime)
  return _internal_createtime();
}
inline void BatchClientRequest::_internal_set_createtime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  createtime_ = value;
}
inline void BatchClientRequest::set_createtime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_createtime(value);
  // @@protoc_insertion_point(field_set:resdb.BatchClientRequest.createtime)
}

// uint64 local_id = 3;
inline void BatchClientRequest::clear_local_id() {
  local_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientRequest::_internal_local_id() const {
  return local_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientRequest::local_id() const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientRequest.local_id)
  return _internal_local_id();
}
inline void BatchClientRequest::_internal_set_local_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  local_id_ = value;
}
inline void BatchClientRequest::set_local_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_local_id(value);
  // @@protoc_insertion_point(field_set:resdb.BatchClientRequest.local_id)
}

// -------------------------------------------------------------------

// BatchClientResponse

// repeated bytes response = 1;
inline int BatchClientResponse::_internal_response_size() const {
  return response_.size();
}
inline int BatchClientResponse::response_size() const {
  return _internal_response_size();
}
inline void BatchClientResponse::clear_response() {
  response_.Clear();
}
inline std::string* BatchClientResponse::add_response() {
  // @@protoc_insertion_point(field_add_mutable:resdb.BatchClientResponse.response)
  return _internal_add_response();
}
inline const std::string& BatchClientResponse::_internal_response(int index) const {
  return response_.Get(index);
}
inline const std::string& BatchClientResponse::response(int index) const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientResponse.response)
  return _internal_response(index);
}
inline std::string* BatchClientResponse::mutable_response(int index) {
  // @@protoc_insertion_point(field_mutable:resdb.BatchClientResponse.response)
  return response_.Mutable(index);
}
inline void BatchClientResponse::set_response(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:resdb.BatchClientResponse.response)
  response_.Mutable(index)->assign(value);
}
inline void BatchClientResponse::set_response(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:resdb.BatchClientResponse.response)
  response_.Mutable(index)->assign(std::move(value));
}
inline void BatchClientResponse::set_response(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  response_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:resdb.BatchClientResponse.response)
}
inline void BatchClientResponse::set_response(int index, const void* value, size_t size) {
  response_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:resdb.BatchClientResponse.response)
}
inline std::string* BatchClientResponse::_internal_add_response() {
  return response_.Add();
}
inline void BatchClientResponse::add_response(const std::string& value) {
  response_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:resdb.BatchClientResponse.response)
}
inline void BatchClientResponse::add_response(std::string&& value) {
  response_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:resdb.BatchClientResponse.response)
}
inline void BatchClientResponse::add_response(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  response_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:resdb.BatchClientResponse.response)
}
inline void BatchClientResponse::add_response(const void* value, size_t size) {
  response_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:resdb.BatchClientResponse.response)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchClientResponse::response() const {
  // @@protoc_insertion_point(field_list:resdb.BatchClientResponse.response)
  return response_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchClientResponse::mutable_response() {
  // @@protoc_insertion_point(field_mutable_list:resdb.BatchClientResponse.response)
  return &response_;
}

// repeated .resdb.SignatureInfo signatures = 2;
inline int BatchClientResponse::_internal_signatures_size() const {
  return signatures_.size();
}
inline int BatchClientResponse::signatures_size() const {
  return _internal_signatures_size();
}
inline ::resdb::SignatureInfo* BatchClientResponse::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:resdb.BatchClientResponse.signatures)
  return signatures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::SignatureInfo >*
BatchClientResponse::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:resdb.BatchClientResponse.signatures)
  return &signatures_;
}
inline const ::resdb::SignatureInfo& BatchClientResponse::_internal_signatures(int index) const {
  return signatures_.Get(index);
}
inline const ::resdb::SignatureInfo& BatchClientResponse::signatures(int index) const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientResponse.signatures)
  return _internal_signatures(index);
}
inline ::resdb::SignatureInfo* BatchClientResponse::_internal_add_signatures() {
  return signatures_.Add();
}
inline ::resdb::SignatureInfo* BatchClientResponse::add_signatures() {
  // @@protoc_insertion_point(field_add:resdb.BatchClientResponse.signatures)
  return _internal_add_signatures();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::SignatureInfo >&
BatchClientResponse::signatures() const {
  // @@protoc_insertion_point(field_list:resdb.BatchClientResponse.signatures)
  return signatures_;
}

// int32 proxy_id = 3;
inline void BatchClientResponse::clear_proxy_id() {
  proxy_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatchClientResponse::_internal_proxy_id() const {
  return proxy_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatchClientResponse::proxy_id() const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientResponse.proxy_id)
  return _internal_proxy_id();
}
inline void BatchClientResponse::_internal_set_proxy_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  proxy_id_ = value;
}
inline void BatchClientResponse::set_proxy_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_proxy_id(value);
  // @@protoc_insertion_point(field_set:resdb.BatchClientResponse.proxy_id)
}

// uint64 seq = 4;
inline void BatchClientResponse::clear_seq() {
  seq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientResponse::_internal_seq() const {
  return seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientResponse::seq() const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientResponse.seq)
  return _internal_seq();
}
inline void BatchClientResponse::_internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  seq_ = value;
}
inline void BatchClientResponse::set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:resdb.BatchClientResponse.seq)
}

// uint64 current_view = 5;
inline void BatchClientResponse::clear_current_view() {
  current_view_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientResponse::_internal_current_view() const {
  return current_view_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientResponse::current_view() const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientResponse.current_view)
  return _internal_current_view();
}
inline void BatchClientResponse::_internal_set_current_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  current_view_ = value;
}
inline void BatchClientResponse::set_current_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_current_view(value);
  // @@protoc_insertion_point(field_set:resdb.BatchClientResponse.current_view)
}

// uint64 createtime = 6;
inline void BatchClientResponse::clear_createtime() {
  createtime_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientResponse::_internal_createtime() const {
  return createtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientResponse::createtime() const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientResponse.createtime)
  return _internal_createtime();
}
inline void BatchClientResponse::_internal_set_createtime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  createtime_ = value;
}
inline void BatchClientResponse::set_createtime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_createtime(value);
  // @@protoc_insertion_point(field_set:resdb.BatchClientResponse.createtime)
}

// uint64 local_id = 7;
inline void BatchClientResponse::clear_local_id() {
  local_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientResponse::_internal_local_id() const {
  return local_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BatchClientResponse::local_id() const {
  // @@protoc_insertion_point(field_get:resdb.BatchClientResponse.local_id)
  return _internal_local_id();
}
inline void BatchClientResponse::_internal_set_local_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  local_id_ = value;
}
inline void BatchClientResponse::set_local_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_local_id(value);
  // @@protoc_insertion_point(field_set:resdb.BatchClientResponse.local_id)
}

// -------------------------------------------------------------------

// HeartBeatInfo

// repeated .resdb.CertificateKey public_keys = 1;
inline int HeartBeatInfo::_internal_public_keys_size() const {
  return public_keys_.size();
}
inline int HeartBeatInfo::public_keys_size() const {
  return _internal_public_keys_size();
}
inline ::resdb::CertificateKey* HeartBeatInfo::mutable_public_keys(int index) {
  // @@protoc_insertion_point(field_mutable:resdb.HeartBeatInfo.public_keys)
  return public_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::CertificateKey >*
HeartBeatInfo::mutable_public_keys() {
  // @@protoc_insertion_point(field_mutable_list:resdb.HeartBeatInfo.public_keys)
  return &public_keys_;
}
inline const ::resdb::CertificateKey& HeartBeatInfo::_internal_public_keys(int index) const {
  return public_keys_.Get(index);
}
inline const ::resdb::CertificateKey& HeartBeatInfo::public_keys(int index) const {
  // @@protoc_insertion_point(field_get:resdb.HeartBeatInfo.public_keys)
  return _internal_public_keys(index);
}
inline ::resdb::CertificateKey* HeartBeatInfo::_internal_add_public_keys() {
  return public_keys_.Add();
}
inline ::resdb::CertificateKey* HeartBeatInfo::add_public_keys() {
  // @@protoc_insertion_point(field_add:resdb.HeartBeatInfo.public_keys)
  return _internal_add_public_keys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::CertificateKey >&
HeartBeatInfo::public_keys() const {
  // @@protoc_insertion_point(field_list:resdb.HeartBeatInfo.public_keys)
  return public_keys_;
}

// -------------------------------------------------------------------

// ClientCertInfo

// .resdb.CertificateKey public_key = 1;
inline bool ClientCertInfo::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool ClientCertInfo::has_public_key() const {
  return _internal_has_public_key();
}
inline const ::resdb::CertificateKey& ClientCertInfo::_internal_public_key() const {
  const ::resdb::CertificateKey* p = public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::CertificateKey&>(
      ::resdb::_CertificateKey_default_instance_);
}
inline const ::resdb::CertificateKey& ClientCertInfo::public_key() const {
  // @@protoc_insertion_point(field_get:resdb.ClientCertInfo.public_key)
  return _internal_public_key();
}
inline void ClientCertInfo::unsafe_arena_set_allocated_public_key(
    ::resdb::CertificateKey* public_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.ClientCertInfo.public_key)
}
inline ::resdb::CertificateKey* ClientCertInfo::release_public_key() {
  
  ::resdb::CertificateKey* temp = public_key_;
  public_key_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::CertificateKey* ClientCertInfo::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:resdb.ClientCertInfo.public_key)
  
  ::resdb::CertificateKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::resdb::CertificateKey* ClientCertInfo::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::CertificateKey>(GetArenaForAllocation());
    public_key_ = p;
  }
  return public_key_;
}
inline ::resdb::CertificateKey* ClientCertInfo::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:resdb.ClientCertInfo.public_key)
  return _internal_mutable_public_key();
}
inline void ClientCertInfo::set_allocated_public_key(::resdb::CertificateKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key));
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:resdb.ClientCertInfo.public_key)
}

// .resdb.ReplicaInfo client_info = 2;
inline bool ClientCertInfo::_internal_has_client_info() const {
  return this != internal_default_instance() && client_info_ != nullptr;
}
inline bool ClientCertInfo::has_client_info() const {
  return _internal_has_client_info();
}
inline const ::resdb::ReplicaInfo& ClientCertInfo::_internal_client_info() const {
  const ::resdb::ReplicaInfo* p = client_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::ReplicaInfo&>(
      ::resdb::_ReplicaInfo_default_instance_);
}
inline const ::resdb::ReplicaInfo& ClientCertInfo::client_info() const {
  // @@protoc_insertion_point(field_get:resdb.ClientCertInfo.client_info)
  return _internal_client_info();
}
inline void ClientCertInfo::unsafe_arena_set_allocated_client_info(
    ::resdb::ReplicaInfo* client_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_info_);
  }
  client_info_ = client_info;
  if (client_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.ClientCertInfo.client_info)
}
inline ::resdb::ReplicaInfo* ClientCertInfo::release_client_info() {
  
  ::resdb::ReplicaInfo* temp = client_info_;
  client_info_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::ReplicaInfo* ClientCertInfo::unsafe_arena_release_client_info() {
  // @@protoc_insertion_point(field_release:resdb.ClientCertInfo.client_info)
  
  ::resdb::ReplicaInfo* temp = client_info_;
  client_info_ = nullptr;
  return temp;
}
inline ::resdb::ReplicaInfo* ClientCertInfo::_internal_mutable_client_info() {
  
  if (client_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::ReplicaInfo>(GetArenaForAllocation());
    client_info_ = p;
  }
  return client_info_;
}
inline ::resdb::ReplicaInfo* ClientCertInfo::mutable_client_info() {
  // @@protoc_insertion_point(field_mutable:resdb.ClientCertInfo.client_info)
  return _internal_mutable_client_info();
}
inline void ClientCertInfo::set_allocated_client_info(::resdb::ReplicaInfo* client_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_info_);
  }
  if (client_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_info));
    if (message_arena != submessage_arena) {
      client_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:resdb.ClientCertInfo.client_info)
}

// -------------------------------------------------------------------

// ClientCertResponse

// repeated .resdb.CertificateKey public_keys = 1;
inline int ClientCertResponse::_internal_public_keys_size() const {
  return public_keys_.size();
}
inline int ClientCertResponse::public_keys_size() const {
  return _internal_public_keys_size();
}
inline ::resdb::CertificateKey* ClientCertResponse::mutable_public_keys(int index) {
  // @@protoc_insertion_point(field_mutable:resdb.ClientCertResponse.public_keys)
  return public_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::CertificateKey >*
ClientCertResponse::mutable_public_keys() {
  // @@protoc_insertion_point(field_mutable_list:resdb.ClientCertResponse.public_keys)
  return &public_keys_;
}
inline const ::resdb::CertificateKey& ClientCertResponse::_internal_public_keys(int index) const {
  return public_keys_.Get(index);
}
inline const ::resdb::CertificateKey& ClientCertResponse::public_keys(int index) const {
  // @@protoc_insertion_point(field_get:resdb.ClientCertResponse.public_keys)
  return _internal_public_keys(index);
}
inline ::resdb::CertificateKey* ClientCertResponse::_internal_add_public_keys() {
  return public_keys_.Add();
}
inline ::resdb::CertificateKey* ClientCertResponse::add_public_keys() {
  // @@protoc_insertion_point(field_add:resdb.ClientCertResponse.public_keys)
  return _internal_add_public_keys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::CertificateKey >&
ClientCertResponse::public_keys() const {
  // @@protoc_insertion_point(field_list:resdb.ClientCertResponse.public_keys)
  return public_keys_;
}

// repeated .resdb.ReplicaInfo replicas = 2;
inline int ClientCertResponse::_internal_replicas_size() const {
  return replicas_.size();
}
inline int ClientCertResponse::replicas_size() const {
  return _internal_replicas_size();
}
inline ::resdb::ReplicaInfo* ClientCertResponse::mutable_replicas(int index) {
  // @@protoc_insertion_point(field_mutable:resdb.ClientCertResponse.replicas)
  return replicas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::ReplicaInfo >*
ClientCertResponse::mutable_replicas() {
  // @@protoc_insertion_point(field_mutable_list:resdb.ClientCertResponse.replicas)
  return &replicas_;
}
inline const ::resdb::ReplicaInfo& ClientCertResponse::_internal_replicas(int index) const {
  return replicas_.Get(index);
}
inline const ::resdb::ReplicaInfo& ClientCertResponse::replicas(int index) const {
  // @@protoc_insertion_point(field_get:resdb.ClientCertResponse.replicas)
  return _internal_replicas(index);
}
inline ::resdb::ReplicaInfo* ClientCertResponse::_internal_add_replicas() {
  return replicas_.Add();
}
inline ::resdb::ReplicaInfo* ClientCertResponse::add_replicas() {
  // @@protoc_insertion_point(field_add:resdb.ClientCertResponse.replicas)
  return _internal_add_replicas();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::ReplicaInfo >&
ClientCertResponse::replicas() const {
  // @@protoc_insertion_point(field_list:resdb.ClientCertResponse.replicas)
  return replicas_;
}

// -------------------------------------------------------------------

// NewReplicaRequest

// .resdb.ReplicaInfo replica_info = 1;
inline bool NewReplicaRequest::_internal_has_replica_info() const {
  return this != internal_default_instance() && replica_info_ != nullptr;
}
inline bool NewReplicaRequest::has_replica_info() const {
  return _internal_has_replica_info();
}
inline const ::resdb::ReplicaInfo& NewReplicaRequest::_internal_replica_info() const {
  const ::resdb::ReplicaInfo* p = replica_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::ReplicaInfo&>(
      ::resdb::_ReplicaInfo_default_instance_);
}
inline const ::resdb::ReplicaInfo& NewReplicaRequest::replica_info() const {
  // @@protoc_insertion_point(field_get:resdb.NewReplicaRequest.replica_info)
  return _internal_replica_info();
}
inline void NewReplicaRequest::unsafe_arena_set_allocated_replica_info(
    ::resdb::ReplicaInfo* replica_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(replica_info_);
  }
  replica_info_ = replica_info;
  if (replica_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.NewReplicaRequest.replica_info)
}
inline ::resdb::ReplicaInfo* NewReplicaRequest::release_replica_info() {
  
  ::resdb::ReplicaInfo* temp = replica_info_;
  replica_info_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::ReplicaInfo* NewReplicaRequest::unsafe_arena_release_replica_info() {
  // @@protoc_insertion_point(field_release:resdb.NewReplicaRequest.replica_info)
  
  ::resdb::ReplicaInfo* temp = replica_info_;
  replica_info_ = nullptr;
  return temp;
}
inline ::resdb::ReplicaInfo* NewReplicaRequest::_internal_mutable_replica_info() {
  
  if (replica_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::ReplicaInfo>(GetArenaForAllocation());
    replica_info_ = p;
  }
  return replica_info_;
}
inline ::resdb::ReplicaInfo* NewReplicaRequest::mutable_replica_info() {
  // @@protoc_insertion_point(field_mutable:resdb.NewReplicaRequest.replica_info)
  return _internal_mutable_replica_info();
}
inline void NewReplicaRequest::set_allocated_replica_info(::resdb::ReplicaInfo* replica_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(replica_info_);
  }
  if (replica_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(replica_info));
    if (message_arena != submessage_arena) {
      replica_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, replica_info, submessage_arena);
    }
    
  } else {
    
  }
  replica_info_ = replica_info;
  // @@protoc_insertion_point(field_set_allocated:resdb.NewReplicaRequest.replica_info)
}

// -------------------------------------------------------------------

// SystemInfoRequest

// .resdb.SystemInfoRequest.Type type = 1;
inline void SystemInfoRequest::clear_type() {
  type_ = 0;
}
inline ::resdb::SystemInfoRequest_Type SystemInfoRequest::_internal_type() const {
  return static_cast< ::resdb::SystemInfoRequest_Type >(type_);
}
inline ::resdb::SystemInfoRequest_Type SystemInfoRequest::type() const {
  // @@protoc_insertion_point(field_get:resdb.SystemInfoRequest.type)
  return _internal_type();
}
inline void SystemInfoRequest::_internal_set_type(::resdb::SystemInfoRequest_Type value) {
  
  type_ = value;
}
inline void SystemInfoRequest::set_type(::resdb::SystemInfoRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:resdb.SystemInfoRequest.type)
}

// bytes request = 2;
inline void SystemInfoRequest::clear_request() {
  request_.ClearToEmpty();
}
inline const std::string& SystemInfoRequest::request() const {
  // @@protoc_insertion_point(field_get:resdb.SystemInfoRequest.request)
  return _internal_request();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemInfoRequest::set_request(ArgT0&& arg0, ArgT... args) {
 
 request_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resdb.SystemInfoRequest.request)
}
inline std::string* SystemInfoRequest::mutable_request() {
  // @@protoc_insertion_point(field_mutable:resdb.SystemInfoRequest.request)
  return _internal_mutable_request();
}
inline const std::string& SystemInfoRequest::_internal_request() const {
  return request_.Get();
}
inline void SystemInfoRequest::_internal_set_request(const std::string& value) {
  
  request_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SystemInfoRequest::_internal_mutable_request() {
  
  return request_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SystemInfoRequest::release_request() {
  // @@protoc_insertion_point(field_release:resdb.SystemInfoRequest.request)
  return request_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SystemInfoRequest::set_allocated_request(std::string* request) {
  if (request != nullptr) {
    
  } else {
    
  }
  request_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:resdb.SystemInfoRequest.request)
}

// -------------------------------------------------------------------

// RecoveryRequest

// uint64 min_seq = 1;
inline void RecoveryRequest::clear_min_seq() {
  min_seq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RecoveryRequest::_internal_min_seq() const {
  return min_seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RecoveryRequest::min_seq() const {
  // @@protoc_insertion_point(field_get:resdb.RecoveryRequest.min_seq)
  return _internal_min_seq();
}
inline void RecoveryRequest::_internal_set_min_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  min_seq_ = value;
}
inline void RecoveryRequest::set_min_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_min_seq(value);
  // @@protoc_insertion_point(field_set:resdb.RecoveryRequest.min_seq)
}

// uint64 max_seq = 2;
inline void RecoveryRequest::clear_max_seq() {
  max_seq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RecoveryRequest::_internal_max_seq() const {
  return max_seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RecoveryRequest::max_seq() const {
  // @@protoc_insertion_point(field_get:resdb.RecoveryRequest.max_seq)
  return _internal_max_seq();
}
inline void RecoveryRequest::_internal_set_max_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  max_seq_ = value;
}
inline void RecoveryRequest::set_max_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_max_seq(value);
  // @@protoc_insertion_point(field_set:resdb.RecoveryRequest.max_seq)
}

// -------------------------------------------------------------------

// RecoveryResponse

// repeated .resdb.Request request = 1;
inline int RecoveryResponse::_internal_request_size() const {
  return request_.size();
}
inline int RecoveryResponse::request_size() const {
  return _internal_request_size();
}
inline void RecoveryResponse::clear_request() {
  request_.Clear();
}
inline ::resdb::Request* RecoveryResponse::mutable_request(int index) {
  // @@protoc_insertion_point(field_mutable:resdb.RecoveryResponse.request)
  return request_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::Request >*
RecoveryResponse::mutable_request() {
  // @@protoc_insertion_point(field_mutable_list:resdb.RecoveryResponse.request)
  return &request_;
}
inline const ::resdb::Request& RecoveryResponse::_internal_request(int index) const {
  return request_.Get(index);
}
inline const ::resdb::Request& RecoveryResponse::request(int index) const {
  // @@protoc_insertion_point(field_get:resdb.RecoveryResponse.request)
  return _internal_request(index);
}
inline ::resdb::Request* RecoveryResponse::_internal_add_request() {
  return request_.Add();
}
inline ::resdb::Request* RecoveryResponse::add_request() {
  // @@protoc_insertion_point(field_add:resdb.RecoveryResponse.request)
  return _internal_add_request();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::Request >&
RecoveryResponse::request() const {
  // @@protoc_insertion_point(field_list:resdb.RecoveryResponse.request)
  return request_;
}

// -------------------------------------------------------------------

// RequestWithProof_RequestData

// .resdb.Request request = 1;
inline bool RequestWithProof_RequestData::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool RequestWithProof_RequestData::has_request() const {
  return _internal_has_request();
}
inline void RequestWithProof_RequestData::clear_request() {
  if (GetArenaForAllocation() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::resdb::Request& RequestWithProof_RequestData::_internal_request() const {
  const ::resdb::Request* p = request_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::Request&>(
      ::resdb::_Request_default_instance_);
}
inline const ::resdb::Request& RequestWithProof_RequestData::request() const {
  // @@protoc_insertion_point(field_get:resdb.RequestWithProof.RequestData.request)
  return _internal_request();
}
inline void RequestWithProof_RequestData::unsafe_arena_set_allocated_request(
    ::resdb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.RequestWithProof.RequestData.request)
}
inline ::resdb::Request* RequestWithProof_RequestData::release_request() {
  
  ::resdb::Request* temp = request_;
  request_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::Request* RequestWithProof_RequestData::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:resdb.RequestWithProof.RequestData.request)
  
  ::resdb::Request* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::resdb::Request* RequestWithProof_RequestData::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::Request>(GetArenaForAllocation());
    request_ = p;
  }
  return request_;
}
inline ::resdb::Request* RequestWithProof_RequestData::mutable_request() {
  // @@protoc_insertion_point(field_mutable:resdb.RequestWithProof.RequestData.request)
  return _internal_mutable_request();
}
inline void RequestWithProof_RequestData::set_allocated_request(::resdb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::resdb::Request>::GetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:resdb.RequestWithProof.RequestData.request)
}

// .resdb.SignatureInfo signature = 2;
inline bool RequestWithProof_RequestData::_internal_has_signature() const {
  return this != internal_default_instance() && signature_ != nullptr;
}
inline bool RequestWithProof_RequestData::has_signature() const {
  return _internal_has_signature();
}
inline const ::resdb::SignatureInfo& RequestWithProof_RequestData::_internal_signature() const {
  const ::resdb::SignatureInfo* p = signature_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::SignatureInfo&>(
      ::resdb::_SignatureInfo_default_instance_);
}
inline const ::resdb::SignatureInfo& RequestWithProof_RequestData::signature() const {
  // @@protoc_insertion_point(field_get:resdb.RequestWithProof.RequestData.signature)
  return _internal_signature();
}
inline void RequestWithProof_RequestData::unsafe_arena_set_allocated_signature(
    ::resdb::SignatureInfo* signature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature_);
  }
  signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.RequestWithProof.RequestData.signature)
}
inline ::resdb::SignatureInfo* RequestWithProof_RequestData::release_signature() {
  
  ::resdb::SignatureInfo* temp = signature_;
  signature_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::SignatureInfo* RequestWithProof_RequestData::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_release:resdb.RequestWithProof.RequestData.signature)
  
  ::resdb::SignatureInfo* temp = signature_;
  signature_ = nullptr;
  return temp;
}
inline ::resdb::SignatureInfo* RequestWithProof_RequestData::_internal_mutable_signature() {
  
  if (signature_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::SignatureInfo>(GetArenaForAllocation());
    signature_ = p;
  }
  return signature_;
}
inline ::resdb::SignatureInfo* RequestWithProof_RequestData::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:resdb.RequestWithProof.RequestData.signature)
  return _internal_mutable_signature();
}
inline void RequestWithProof_RequestData::set_allocated_signature(::resdb::SignatureInfo* signature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature_);
  }
  if (signature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signature));
    if (message_arena != submessage_arena) {
      signature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signature, submessage_arena);
    }
    
  } else {
    
  }
  signature_ = signature;
  // @@protoc_insertion_point(field_set_allocated:resdb.RequestWithProof.RequestData.signature)
}

// -------------------------------------------------------------------

// RequestWithProof

// .resdb.Request request = 1;
inline bool RequestWithProof::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool RequestWithProof::has_request() const {
  return _internal_has_request();
}
inline void RequestWithProof::clear_request() {
  if (GetArenaForAllocation() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::resdb::Request& RequestWithProof::_internal_request() const {
  const ::resdb::Request* p = request_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::Request&>(
      ::resdb::_Request_default_instance_);
}
inline const ::resdb::Request& RequestWithProof::request() const {
  // @@protoc_insertion_point(field_get:resdb.RequestWithProof.request)
  return _internal_request();
}
inline void RequestWithProof::unsafe_arena_set_allocated_request(
    ::resdb::Request* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.RequestWithProof.request)
}
inline ::resdb::Request* RequestWithProof::release_request() {
  
  ::resdb::Request* temp = request_;
  request_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::Request* RequestWithProof::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:resdb.RequestWithProof.request)
  
  ::resdb::Request* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::resdb::Request* RequestWithProof::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::Request>(GetArenaForAllocation());
    request_ = p;
  }
  return request_;
}
inline ::resdb::Request* RequestWithProof::mutable_request() {
  // @@protoc_insertion_point(field_mutable:resdb.RequestWithProof.request)
  return _internal_mutable_request();
}
inline void RequestWithProof::set_allocated_request(::resdb::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::resdb::Request>::GetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:resdb.RequestWithProof.request)
}

// repeated .resdb.RequestWithProof.RequestData proofs = 2;
inline int RequestWithProof::_internal_proofs_size() const {
  return proofs_.size();
}
inline int RequestWithProof::proofs_size() const {
  return _internal_proofs_size();
}
inline void RequestWithProof::clear_proofs() {
  proofs_.Clear();
}
inline ::resdb::RequestWithProof_RequestData* RequestWithProof::mutable_proofs(int index) {
  // @@protoc_insertion_point(field_mutable:resdb.RequestWithProof.proofs)
  return proofs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::RequestWithProof_RequestData >*
RequestWithProof::mutable_proofs() {
  // @@protoc_insertion_point(field_mutable_list:resdb.RequestWithProof.proofs)
  return &proofs_;
}
inline const ::resdb::RequestWithProof_RequestData& RequestWithProof::_internal_proofs(int index) const {
  return proofs_.Get(index);
}
inline const ::resdb::RequestWithProof_RequestData& RequestWithProof::proofs(int index) const {
  // @@protoc_insertion_point(field_get:resdb.RequestWithProof.proofs)
  return _internal_proofs(index);
}
inline ::resdb::RequestWithProof_RequestData* RequestWithProof::_internal_add_proofs() {
  return proofs_.Add();
}
inline ::resdb::RequestWithProof_RequestData* RequestWithProof::add_proofs() {
  // @@protoc_insertion_point(field_add:resdb.RequestWithProof.proofs)
  return _internal_add_proofs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::RequestWithProof_RequestData >&
RequestWithProof::proofs() const {
  // @@protoc_insertion_point(field_list:resdb.RequestWithProof.proofs)
  return proofs_;
}

// uint64 seq = 3;
inline void RequestWithProof::clear_seq() {
  seq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestWithProof::_internal_seq() const {
  return seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestWithProof::seq() const {
  // @@protoc_insertion_point(field_get:resdb.RequestWithProof.seq)
  return _internal_seq();
}
inline void RequestWithProof::_internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  seq_ = value;
}
inline void RequestWithProof::set_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:resdb.RequestWithProof.seq)
}

// -------------------------------------------------------------------

// RequestSet

// repeated .resdb.RequestWithProof requests = 1;
inline int RequestSet::_internal_requests_size() const {
  return requests_.size();
}
inline int RequestSet::requests_size() const {
  return _internal_requests_size();
}
inline void RequestSet::clear_requests() {
  requests_.Clear();
}
inline ::resdb::RequestWithProof* RequestSet::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:resdb.RequestSet.requests)
  return requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::RequestWithProof >*
RequestSet::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:resdb.RequestSet.requests)
  return &requests_;
}
inline const ::resdb::RequestWithProof& RequestSet::_internal_requests(int index) const {
  return requests_.Get(index);
}
inline const ::resdb::RequestWithProof& RequestSet::requests(int index) const {
  // @@protoc_insertion_point(field_get:resdb.RequestSet.requests)
  return _internal_requests(index);
}
inline ::resdb::RequestWithProof* RequestSet::_internal_add_requests() {
  return requests_.Add();
}
inline ::resdb::RequestWithProof* RequestSet::add_requests() {
  // @@protoc_insertion_point(field_add:resdb.RequestSet.requests)
  return _internal_add_requests();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::RequestWithProof >&
RequestSet::requests() const {
  // @@protoc_insertion_point(field_list:resdb.RequestSet.requests)
  return requests_;
}

// -------------------------------------------------------------------

// QueryRequest

// uint64 min_seq = 1;
inline void QueryRequest::clear_min_seq() {
  min_seq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QueryRequest::_internal_min_seq() const {
  return min_seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QueryRequest::min_seq() const {
  // @@protoc_insertion_point(field_get:resdb.QueryRequest.min_seq)
  return _internal_min_seq();
}
inline void QueryRequest::_internal_set_min_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  min_seq_ = value;
}
inline void QueryRequest::set_min_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_min_seq(value);
  // @@protoc_insertion_point(field_set:resdb.QueryRequest.min_seq)
}

// uint64 max_seq = 2;
inline void QueryRequest::clear_max_seq() {
  max_seq_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QueryRequest::_internal_max_seq() const {
  return max_seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QueryRequest::max_seq() const {
  // @@protoc_insertion_point(field_get:resdb.QueryRequest.max_seq)
  return _internal_max_seq();
}
inline void QueryRequest::_internal_set_max_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  max_seq_ = value;
}
inline void QueryRequest::set_max_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_max_seq(value);
  // @@protoc_insertion_point(field_set:resdb.QueryRequest.max_seq)
}

// -------------------------------------------------------------------

// QueryResponse

// repeated .resdb.Request transactions = 1;
inline int QueryResponse::_internal_transactions_size() const {
  return transactions_.size();
}
inline int QueryResponse::transactions_size() const {
  return _internal_transactions_size();
}
inline void QueryResponse::clear_transactions() {
  transactions_.Clear();
}
inline ::resdb::Request* QueryResponse::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:resdb.QueryResponse.transactions)
  return transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::Request >*
QueryResponse::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:resdb.QueryResponse.transactions)
  return &transactions_;
}
inline const ::resdb::Request& QueryResponse::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const ::resdb::Request& QueryResponse::transactions(int index) const {
  // @@protoc_insertion_point(field_get:resdb.QueryResponse.transactions)
  return _internal_transactions(index);
}
inline ::resdb::Request* QueryResponse::_internal_add_transactions() {
  return transactions_.Add();
}
inline ::resdb::Request* QueryResponse::add_transactions() {
  // @@protoc_insertion_point(field_add:resdb.QueryResponse.transactions)
  return _internal_add_transactions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::resdb::Request >&
QueryResponse::transactions() const {
  // @@protoc_insertion_point(field_list:resdb.QueryResponse.transactions)
  return transactions_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace resdb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::resdb::Request_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resdb::Request_Type>() {
  return ::resdb::Request_Type_descriptor();
}
template <> struct is_proto_enum< ::resdb::Response_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resdb::Response_Result>() {
  return ::resdb::Response_Result_descriptor();
}
template <> struct is_proto_enum< ::resdb::SystemInfoRequest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resdb::SystemInfoRequest_Type>() {
  return ::resdb::SystemInfoRequest_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fresdb_2eproto
