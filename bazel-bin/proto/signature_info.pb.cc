// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/signature_info.proto

#include "proto/signature_info.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace resdb {
constexpr SignatureInfo::SignatureInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , node_id_(int64_t{0})
  , hash_type_(0)
{}
struct SignatureInfoDefaultTypeInternal {
  constexpr SignatureInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SignatureInfoDefaultTypeInternal() {}
  union {
    SignatureInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SignatureInfoDefaultTypeInternal _SignatureInfo_default_instance_;
constexpr SecretKey::SecretKey(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : public_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , private_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , hash_type_(0)
{}
struct SecretKeyDefaultTypeInternal {
  constexpr SecretKeyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SecretKeyDefaultTypeInternal() {}
  union {
    SecretKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SecretKeyDefaultTypeInternal _SecretKey_default_instance_;
constexpr KeyInfo::KeyInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , hash_type_(0)
{}
struct KeyInfoDefaultTypeInternal {
  constexpr KeyInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyInfoDefaultTypeInternal() {}
  union {
    KeyInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyInfoDefaultTypeInternal _KeyInfo_default_instance_;
constexpr CertificateKeyInfo::CertificateKeyInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , key_(nullptr)
  , node_id_(int64_t{0})
  , type_(0)

  , port_(0){}
struct CertificateKeyInfoDefaultTypeInternal {
  constexpr CertificateKeyInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CertificateKeyInfoDefaultTypeInternal() {}
  union {
    CertificateKeyInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CertificateKeyInfoDefaultTypeInternal _CertificateKeyInfo_default_instance_;
constexpr CertificateKey::CertificateKey(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : public_key_info_(nullptr)
  , certificate_(nullptr){}
struct CertificateKeyDefaultTypeInternal {
  constexpr CertificateKeyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CertificateKeyDefaultTypeInternal() {}
  union {
    CertificateKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CertificateKeyDefaultTypeInternal _CertificateKey_default_instance_;
constexpr CertificateInfo::CertificateInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : admin_public_key_(nullptr)
  , public_key_(nullptr)
  , node_id_(int64_t{0}){}
struct CertificateInfoDefaultTypeInternal {
  constexpr CertificateInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CertificateInfoDefaultTypeInternal() {}
  union {
    CertificateInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CertificateInfoDefaultTypeInternal _CertificateInfo_default_instance_;
constexpr SignatureKeyInfo::SignatureKeyInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : admin_public_key_(nullptr)
  , private_key_(nullptr)
  , node_id_(int64_t{0}){}
struct SignatureKeyInfoDefaultTypeInternal {
  constexpr SignatureKeyInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SignatureKeyInfoDefaultTypeInternal() {}
  union {
    SignatureKeyInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SignatureKeyInfoDefaultTypeInternal _SignatureKeyInfo_default_instance_;
}  // namespace resdb
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_proto_2fsignature_5finfo_2eproto[7];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_proto_2fsignature_5finfo_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_proto_2fsignature_5finfo_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_proto_2fsignature_5finfo_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::resdb::SignatureInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::resdb::SignatureInfo, hash_type_),
  PROTOBUF_FIELD_OFFSET(::resdb::SignatureInfo, node_id_),
  PROTOBUF_FIELD_OFFSET(::resdb::SignatureInfo, signature_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::resdb::SecretKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::resdb::SecretKey, public_key_),
  PROTOBUF_FIELD_OFFSET(::resdb::SecretKey, private_key_),
  PROTOBUF_FIELD_OFFSET(::resdb::SecretKey, hash_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::resdb::KeyInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::resdb::KeyInfo, key_),
  PROTOBUF_FIELD_OFFSET(::resdb::KeyInfo, hash_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateKeyInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateKeyInfo, key_),
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateKeyInfo, node_id_),
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateKeyInfo, type_),
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateKeyInfo, ip_),
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateKeyInfo, port_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateKey, public_key_info_),
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateKey, certificate_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateInfo, admin_public_key_),
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateInfo, public_key_),
  PROTOBUF_FIELD_OFFSET(::resdb::CertificateInfo, node_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::resdb::SignatureKeyInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::resdb::SignatureKeyInfo, admin_public_key_),
  PROTOBUF_FIELD_OFFSET(::resdb::SignatureKeyInfo, private_key_),
  PROTOBUF_FIELD_OFFSET(::resdb::SignatureKeyInfo, node_id_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::resdb::SignatureInfo)},
  { 8, -1, sizeof(::resdb::SecretKey)},
  { 16, -1, sizeof(::resdb::KeyInfo)},
  { 23, -1, sizeof(::resdb::CertificateKeyInfo)},
  { 33, -1, sizeof(::resdb::CertificateKey)},
  { 40, -1, sizeof(::resdb::CertificateInfo)},
  { 48, -1, sizeof(::resdb::SignatureKeyInfo)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::resdb::_SignatureInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::resdb::_SecretKey_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::resdb::_KeyInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::resdb::_CertificateKeyInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::resdb::_CertificateKey_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::resdb::_CertificateInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::resdb::_SignatureKeyInfo_default_instance_),
};

const char descriptor_table_protodef_proto_2fsignature_5finfo_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\032proto/signature_info.proto\022\005resdb\"\237\001\n\r"
  "SignatureInfo\0220\n\thash_type\030\001 \001(\0162\035.resdb"
  ".SignatureInfo.HashType\022\017\n\007node_id\030\002 \001(\003"
  "\022\021\n\tsignature\030\003 \001(\014\"8\n\010HashType\022\010\n\004NONE\020"
  "\000\022\007\n\003RSA\020\001\022\013\n\007ED25519\020\002\022\014\n\010CMAC_AES\020\003\"f\n"
  "\tSecretKey\022\022\n\npublic_key\030\001 \001(\014\022\023\n\013privat"
  "e_key\030\002 \001(\014\0220\n\thash_type\030\003 \001(\0162\035.resdb.S"
  "ignatureInfo.HashType\"H\n\007KeyInfo\022\013\n\003key\030"
  "\001 \001(\014\0220\n\thash_type\030\002 \001(\0162\035.resdb.Signatu"
  "reInfo.HashType\"\253\001\n\022CertificateKeyInfo\022\033"
  "\n\003key\030\001 \001(\0132\016.resdb.KeyInfo\022\017\n\007node_id\030\002"
  " \001(\003\022,\n\004type\030\003 \001(\0162\036.resdb.CertificateKe"
  "yInfo.Type\022\n\n\002ip\030\004 \001(\t\022\014\n\004port\030\005 \001(\005\"\037\n\004"
  "Type\022\013\n\007REPLICA\020\000\022\n\n\006CLIENT\020\001\"o\n\016Certifi"
  "cateKey\0222\n\017public_key_info\030\001 \001(\0132\031.resdb"
  ".CertificateKeyInfo\022)\n\013certificate\030\002 \001(\013"
  "2\024.resdb.SignatureInfo\"w\n\017CertificateInf"
  "o\022(\n\020admin_public_key\030\001 \001(\0132\016.resdb.KeyI"
  "nfo\022)\n\npublic_key\030\003 \001(\0132\025.resdb.Certific"
  "ateKey\022\017\n\007node_id\030\004 \001(\003\"r\n\020SignatureKeyI"
  "nfo\022(\n\020admin_public_key\030\001 \001(\0132\016.resdb.Ke"
  "yInfo\022#\n\013private_key\030\002 \001(\0132\016.resdb.KeyIn"
  "fo\022\017\n\007node_id\030\003 \001(\003b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_proto_2fsignature_5finfo_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fsignature_5finfo_2eproto = {
  false, false, 907, descriptor_table_protodef_proto_2fsignature_5finfo_2eproto, "proto/signature_info.proto", 
  &descriptor_table_proto_2fsignature_5finfo_2eproto_once, nullptr, 0, 7,
  schemas, file_default_instances, TableStruct_proto_2fsignature_5finfo_2eproto::offsets,
  file_level_metadata_proto_2fsignature_5finfo_2eproto, file_level_enum_descriptors_proto_2fsignature_5finfo_2eproto, file_level_service_descriptors_proto_2fsignature_5finfo_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_proto_2fsignature_5finfo_2eproto_getter() {
  return &descriptor_table_proto_2fsignature_5finfo_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_proto_2fsignature_5finfo_2eproto(&descriptor_table_proto_2fsignature_5finfo_2eproto);
namespace resdb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignatureInfo_HashType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fsignature_5finfo_2eproto);
  return file_level_enum_descriptors_proto_2fsignature_5finfo_2eproto[0];
}
bool SignatureInfo_HashType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SignatureInfo_HashType SignatureInfo::NONE;
constexpr SignatureInfo_HashType SignatureInfo::RSA;
constexpr SignatureInfo_HashType SignatureInfo::ED25519;
constexpr SignatureInfo_HashType SignatureInfo::CMAC_AES;
constexpr SignatureInfo_HashType SignatureInfo::HashType_MIN;
constexpr SignatureInfo_HashType SignatureInfo::HashType_MAX;
constexpr int SignatureInfo::HashType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CertificateKeyInfo_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fsignature_5finfo_2eproto);
  return file_level_enum_descriptors_proto_2fsignature_5finfo_2eproto[1];
}
bool CertificateKeyInfo_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CertificateKeyInfo_Type CertificateKeyInfo::REPLICA;
constexpr CertificateKeyInfo_Type CertificateKeyInfo::CLIENT;
constexpr CertificateKeyInfo_Type CertificateKeyInfo::Type_MIN;
constexpr CertificateKeyInfo_Type CertificateKeyInfo::Type_MAX;
constexpr int CertificateKeyInfo::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

class SignatureInfo::_Internal {
 public:
};

SignatureInfo::SignatureInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:resdb.SignatureInfo)
}
SignatureInfo::SignatureInfo(const SignatureInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_signature().empty()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  ::memcpy(&node_id_, &from.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&hash_type_) -
    reinterpret_cast<char*>(&node_id_)) + sizeof(hash_type_));
  // @@protoc_insertion_point(copy_constructor:resdb.SignatureInfo)
}

void SignatureInfo::SharedCtor() {
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&node_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hash_type_) -
    reinterpret_cast<char*>(&node_id_)) + sizeof(hash_type_));
}

SignatureInfo::~SignatureInfo() {
  // @@protoc_insertion_point(destructor:resdb.SignatureInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SignatureInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SignatureInfo::ArenaDtor(void* object) {
  SignatureInfo* _this = reinterpret_cast< SignatureInfo* >(object);
  (void)_this;
}
void SignatureInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SignatureInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SignatureInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:resdb.SignatureInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  signature_.ClearToEmpty();
  ::memset(&node_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hash_type_) -
      reinterpret_cast<char*>(&node_id_)) + sizeof(hash_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignatureInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .resdb.SignatureInfo.HashType hash_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hash_type(static_cast<::resdb::SignatureInfo_HashType>(val));
        } else goto handle_unusual;
        continue;
      // int64 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bytes signature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SignatureInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:resdb.SignatureInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .resdb.SignatureInfo.HashType hash_type = 1;
  if (this->hash_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_hash_type(), target);
  }

  // int64 node_id = 2;
  if (this->node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_node_id(), target);
  }

  // bytes signature = 3;
  if (!this->signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:resdb.SignatureInfo)
  return target;
}

size_t SignatureInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:resdb.SignatureInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes signature = 3;
  if (!this->signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  // int64 node_id = 2;
  if (this->node_id() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_node_id());
  }

  // .resdb.SignatureInfo.HashType hash_type = 1;
  if (this->hash_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hash_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SignatureInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:resdb.SignatureInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const SignatureInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SignatureInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:resdb.SignatureInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:resdb.SignatureInfo)
    MergeFrom(*source);
  }
}

void SignatureInfo::MergeFrom(const SignatureInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:resdb.SignatureInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from.signature().empty()) {
    _internal_set_signature(from._internal_signature());
  }
  if (from.node_id() != 0) {
    _internal_set_node_id(from._internal_node_id());
  }
  if (from.hash_type() != 0) {
    _internal_set_hash_type(from._internal_hash_type());
  }
}

void SignatureInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:resdb.SignatureInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignatureInfo::CopyFrom(const SignatureInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:resdb.SignatureInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignatureInfo::IsInitialized() const {
  return true;
}

void SignatureInfo::InternalSwap(SignatureInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, GetArenaForAllocation(),
      &other->signature_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SignatureInfo, hash_type_)
      + sizeof(SignatureInfo::hash_type_)
      - PROTOBUF_FIELD_OFFSET(SignatureInfo, node_id_)>(
          reinterpret_cast<char*>(&node_id_),
          reinterpret_cast<char*>(&other->node_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SignatureInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fsignature_5finfo_2eproto_getter, &descriptor_table_proto_2fsignature_5finfo_2eproto_once,
      file_level_metadata_proto_2fsignature_5finfo_2eproto[0]);
}

// ===================================================================

class SecretKey::_Internal {
 public:
};

SecretKey::SecretKey(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:resdb.SecretKey)
}
SecretKey::SecretKey(const SecretKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  public_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_public_key().empty()) {
    public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_public_key(), 
      GetArenaForAllocation());
  }
  private_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_private_key().empty()) {
    private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_private_key(), 
      GetArenaForAllocation());
  }
  hash_type_ = from.hash_type_;
  // @@protoc_insertion_point(copy_constructor:resdb.SecretKey)
}

void SecretKey::SharedCtor() {
public_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
private_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
hash_type_ = 0;
}

SecretKey::~SecretKey() {
  // @@protoc_insertion_point(destructor:resdb.SecretKey)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SecretKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  public_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  private_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SecretKey::ArenaDtor(void* object) {
  SecretKey* _this = reinterpret_cast< SecretKey* >(object);
  (void)_this;
}
void SecretKey::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SecretKey::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SecretKey::Clear() {
// @@protoc_insertion_point(message_clear_start:resdb.SecretKey)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  public_key_.ClearToEmpty();
  private_key_.ClearToEmpty();
  hash_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecretKey::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_public_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bytes private_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_private_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .resdb.SignatureInfo.HashType hash_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hash_type(static_cast<::resdb::SignatureInfo_HashType>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SecretKey::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:resdb.SecretKey)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes public_key = 1;
  if (!this->public_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_public_key(), target);
  }

  // bytes private_key = 2;
  if (!this->private_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_private_key(), target);
  }

  // .resdb.SignatureInfo.HashType hash_type = 3;
  if (this->hash_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_hash_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:resdb.SecretKey)
  return target;
}

size_t SecretKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:resdb.SecretKey)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes public_key = 1;
  if (!this->public_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_public_key());
  }

  // bytes private_key = 2;
  if (!this->private_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_private_key());
  }

  // .resdb.SignatureInfo.HashType hash_type = 3;
  if (this->hash_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hash_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SecretKey::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:resdb.SecretKey)
  GOOGLE_DCHECK_NE(&from, this);
  const SecretKey* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SecretKey>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:resdb.SecretKey)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:resdb.SecretKey)
    MergeFrom(*source);
  }
}

void SecretKey::MergeFrom(const SecretKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:resdb.SecretKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from.public_key().empty()) {
    _internal_set_public_key(from._internal_public_key());
  }
  if (!from.private_key().empty()) {
    _internal_set_private_key(from._internal_private_key());
  }
  if (from.hash_type() != 0) {
    _internal_set_hash_type(from._internal_hash_type());
  }
}

void SecretKey::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:resdb.SecretKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SecretKey::CopyFrom(const SecretKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:resdb.SecretKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecretKey::IsInitialized() const {
  return true;
}

void SecretKey::InternalSwap(SecretKey* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &public_key_, GetArenaForAllocation(),
      &other->public_key_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &private_key_, GetArenaForAllocation(),
      &other->private_key_, other->GetArenaForAllocation()
  );
  swap(hash_type_, other->hash_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SecretKey::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fsignature_5finfo_2eproto_getter, &descriptor_table_proto_2fsignature_5finfo_2eproto_once,
      file_level_metadata_proto_2fsignature_5finfo_2eproto[1]);
}

// ===================================================================

class KeyInfo::_Internal {
 public:
};

KeyInfo::KeyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:resdb.KeyInfo)
}
KeyInfo::KeyInfo(const KeyInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_key().empty()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  hash_type_ = from.hash_type_;
  // @@protoc_insertion_point(copy_constructor:resdb.KeyInfo)
}

void KeyInfo::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
hash_type_ = 0;
}

KeyInfo::~KeyInfo() {
  // @@protoc_insertion_point(destructor:resdb.KeyInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void KeyInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void KeyInfo::ArenaDtor(void* object) {
  KeyInfo* _this = reinterpret_cast< KeyInfo* >(object);
  (void)_this;
}
void KeyInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:resdb.KeyInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  key_.ClearToEmpty();
  hash_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .resdb.SignatureInfo.HashType hash_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hash_type(static_cast<::resdb::SignatureInfo_HashType>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* KeyInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:resdb.KeyInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // .resdb.SignatureInfo.HashType hash_type = 2;
  if (this->hash_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_hash_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:resdb.KeyInfo)
  return target;
}

size_t KeyInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:resdb.KeyInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 1;
  if (!this->key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  // .resdb.SignatureInfo.HashType hash_type = 2;
  if (this->hash_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hash_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeyInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:resdb.KeyInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const KeyInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<KeyInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:resdb.KeyInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:resdb.KeyInfo)
    MergeFrom(*source);
  }
}

void KeyInfo::MergeFrom(const KeyInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:resdb.KeyInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from.key().empty()) {
    _internal_set_key(from._internal_key());
  }
  if (from.hash_type() != 0) {
    _internal_set_hash_type(from._internal_hash_type());
  }
}

void KeyInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:resdb.KeyInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyInfo::CopyFrom(const KeyInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:resdb.KeyInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyInfo::IsInitialized() const {
  return true;
}

void KeyInfo::InternalSwap(KeyInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, GetArenaForAllocation(),
      &other->key_, other->GetArenaForAllocation()
  );
  swap(hash_type_, other->hash_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fsignature_5finfo_2eproto_getter, &descriptor_table_proto_2fsignature_5finfo_2eproto_once,
      file_level_metadata_proto_2fsignature_5finfo_2eproto[2]);
}

// ===================================================================

class CertificateKeyInfo::_Internal {
 public:
  static const ::resdb::KeyInfo& key(const CertificateKeyInfo* msg);
};

const ::resdb::KeyInfo&
CertificateKeyInfo::_Internal::key(const CertificateKeyInfo* msg) {
  return *msg->key_;
}
CertificateKeyInfo::CertificateKeyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:resdb.CertificateKeyInfo)
}
CertificateKeyInfo::CertificateKeyInfo(const CertificateKeyInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_ip().empty()) {
    ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_key()) {
    key_ = new ::resdb::KeyInfo(*from.key_);
  } else {
    key_ = nullptr;
  }
  ::memcpy(&node_id_, &from.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&port_) -
    reinterpret_cast<char*>(&node_id_)) + sizeof(port_));
  // @@protoc_insertion_point(copy_constructor:resdb.CertificateKeyInfo)
}

void CertificateKeyInfo::SharedCtor() {
ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&key_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&port_) -
    reinterpret_cast<char*>(&key_)) + sizeof(port_));
}

CertificateKeyInfo::~CertificateKeyInfo() {
  // @@protoc_insertion_point(destructor:resdb.CertificateKeyInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CertificateKeyInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete key_;
}

void CertificateKeyInfo::ArenaDtor(void* object) {
  CertificateKeyInfo* _this = reinterpret_cast< CertificateKeyInfo* >(object);
  (void)_this;
}
void CertificateKeyInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CertificateKeyInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CertificateKeyInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:resdb.CertificateKeyInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ip_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
  ::memset(&node_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&port_) -
      reinterpret_cast<char*>(&node_id_)) + sizeof(port_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CertificateKeyInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .resdb.KeyInfo key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .resdb.CertificateKeyInfo.Type type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::resdb::CertificateKeyInfo_Type>(val));
        } else goto handle_unusual;
        continue;
      // string ip = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "resdb.CertificateKeyInfo.ip"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 port = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CertificateKeyInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:resdb.CertificateKeyInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .resdb.KeyInfo key = 1;
  if (this->has_key()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::key(this), target, stream);
  }

  // int64 node_id = 2;
  if (this->node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_node_id(), target);
  }

  // .resdb.CertificateKeyInfo.Type type = 3;
  if (this->type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // string ip = 4;
  if (!this->ip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ip().data(), static_cast<int>(this->_internal_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "resdb.CertificateKeyInfo.ip");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_ip(), target);
  }

  // int32 port = 5;
  if (this->port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:resdb.CertificateKeyInfo)
  return target;
}

size_t CertificateKeyInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:resdb.CertificateKeyInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ip = 4;
  if (!this->ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  // .resdb.KeyInfo key = 1;
  if (this->has_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *key_);
  }

  // int64 node_id = 2;
  if (this->node_id() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_node_id());
  }

  // .resdb.CertificateKeyInfo.Type type = 3;
  if (this->type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  // int32 port = 5;
  if (this->port() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_port());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertificateKeyInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:resdb.CertificateKeyInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const CertificateKeyInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CertificateKeyInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:resdb.CertificateKeyInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:resdb.CertificateKeyInfo)
    MergeFrom(*source);
  }
}

void CertificateKeyInfo::MergeFrom(const CertificateKeyInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:resdb.CertificateKeyInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from.ip().empty()) {
    _internal_set_ip(from._internal_ip());
  }
  if (from.has_key()) {
    _internal_mutable_key()->::resdb::KeyInfo::MergeFrom(from._internal_key());
  }
  if (from.node_id() != 0) {
    _internal_set_node_id(from._internal_node_id());
  }
  if (from.type() != 0) {
    _internal_set_type(from._internal_type());
  }
  if (from.port() != 0) {
    _internal_set_port(from._internal_port());
  }
}

void CertificateKeyInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:resdb.CertificateKeyInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CertificateKeyInfo::CopyFrom(const CertificateKeyInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:resdb.CertificateKeyInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertificateKeyInfo::IsInitialized() const {
  return true;
}

void CertificateKeyInfo::InternalSwap(CertificateKeyInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_, GetArenaForAllocation(),
      &other->ip_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CertificateKeyInfo, port_)
      + sizeof(CertificateKeyInfo::port_)
      - PROTOBUF_FIELD_OFFSET(CertificateKeyInfo, key_)>(
          reinterpret_cast<char*>(&key_),
          reinterpret_cast<char*>(&other->key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CertificateKeyInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fsignature_5finfo_2eproto_getter, &descriptor_table_proto_2fsignature_5finfo_2eproto_once,
      file_level_metadata_proto_2fsignature_5finfo_2eproto[3]);
}

// ===================================================================

class CertificateKey::_Internal {
 public:
  static const ::resdb::CertificateKeyInfo& public_key_info(const CertificateKey* msg);
  static const ::resdb::SignatureInfo& certificate(const CertificateKey* msg);
};

const ::resdb::CertificateKeyInfo&
CertificateKey::_Internal::public_key_info(const CertificateKey* msg) {
  return *msg->public_key_info_;
}
const ::resdb::SignatureInfo&
CertificateKey::_Internal::certificate(const CertificateKey* msg) {
  return *msg->certificate_;
}
CertificateKey::CertificateKey(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:resdb.CertificateKey)
}
CertificateKey::CertificateKey(const CertificateKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_public_key_info()) {
    public_key_info_ = new ::resdb::CertificateKeyInfo(*from.public_key_info_);
  } else {
    public_key_info_ = nullptr;
  }
  if (from._internal_has_certificate()) {
    certificate_ = new ::resdb::SignatureInfo(*from.certificate_);
  } else {
    certificate_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:resdb.CertificateKey)
}

void CertificateKey::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&public_key_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&certificate_) -
    reinterpret_cast<char*>(&public_key_info_)) + sizeof(certificate_));
}

CertificateKey::~CertificateKey() {
  // @@protoc_insertion_point(destructor:resdb.CertificateKey)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CertificateKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete public_key_info_;
  if (this != internal_default_instance()) delete certificate_;
}

void CertificateKey::ArenaDtor(void* object) {
  CertificateKey* _this = reinterpret_cast< CertificateKey* >(object);
  (void)_this;
}
void CertificateKey::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CertificateKey::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CertificateKey::Clear() {
// @@protoc_insertion_point(message_clear_start:resdb.CertificateKey)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && public_key_info_ != nullptr) {
    delete public_key_info_;
  }
  public_key_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && certificate_ != nullptr) {
    delete certificate_;
  }
  certificate_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CertificateKey::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .resdb.CertificateKeyInfo public_key_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_key_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .resdb.SignatureInfo certificate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_certificate(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CertificateKey::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:resdb.CertificateKey)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .resdb.CertificateKeyInfo public_key_info = 1;
  if (this->has_public_key_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::public_key_info(this), target, stream);
  }

  // .resdb.SignatureInfo certificate = 2;
  if (this->has_certificate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::certificate(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:resdb.CertificateKey)
  return target;
}

size_t CertificateKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:resdb.CertificateKey)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .resdb.CertificateKeyInfo public_key_info = 1;
  if (this->has_public_key_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *public_key_info_);
  }

  // .resdb.SignatureInfo certificate = 2;
  if (this->has_certificate()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *certificate_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertificateKey::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:resdb.CertificateKey)
  GOOGLE_DCHECK_NE(&from, this);
  const CertificateKey* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CertificateKey>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:resdb.CertificateKey)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:resdb.CertificateKey)
    MergeFrom(*source);
  }
}

void CertificateKey::MergeFrom(const CertificateKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:resdb.CertificateKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_public_key_info()) {
    _internal_mutable_public_key_info()->::resdb::CertificateKeyInfo::MergeFrom(from._internal_public_key_info());
  }
  if (from.has_certificate()) {
    _internal_mutable_certificate()->::resdb::SignatureInfo::MergeFrom(from._internal_certificate());
  }
}

void CertificateKey::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:resdb.CertificateKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CertificateKey::CopyFrom(const CertificateKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:resdb.CertificateKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertificateKey::IsInitialized() const {
  return true;
}

void CertificateKey::InternalSwap(CertificateKey* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CertificateKey, certificate_)
      + sizeof(CertificateKey::certificate_)
      - PROTOBUF_FIELD_OFFSET(CertificateKey, public_key_info_)>(
          reinterpret_cast<char*>(&public_key_info_),
          reinterpret_cast<char*>(&other->public_key_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CertificateKey::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fsignature_5finfo_2eproto_getter, &descriptor_table_proto_2fsignature_5finfo_2eproto_once,
      file_level_metadata_proto_2fsignature_5finfo_2eproto[4]);
}

// ===================================================================

class CertificateInfo::_Internal {
 public:
  static const ::resdb::KeyInfo& admin_public_key(const CertificateInfo* msg);
  static const ::resdb::CertificateKey& public_key(const CertificateInfo* msg);
};

const ::resdb::KeyInfo&
CertificateInfo::_Internal::admin_public_key(const CertificateInfo* msg) {
  return *msg->admin_public_key_;
}
const ::resdb::CertificateKey&
CertificateInfo::_Internal::public_key(const CertificateInfo* msg) {
  return *msg->public_key_;
}
CertificateInfo::CertificateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:resdb.CertificateInfo)
}
CertificateInfo::CertificateInfo(const CertificateInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_admin_public_key()) {
    admin_public_key_ = new ::resdb::KeyInfo(*from.admin_public_key_);
  } else {
    admin_public_key_ = nullptr;
  }
  if (from._internal_has_public_key()) {
    public_key_ = new ::resdb::CertificateKey(*from.public_key_);
  } else {
    public_key_ = nullptr;
  }
  node_id_ = from.node_id_;
  // @@protoc_insertion_point(copy_constructor:resdb.CertificateInfo)
}

void CertificateInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&admin_public_key_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&node_id_) -
    reinterpret_cast<char*>(&admin_public_key_)) + sizeof(node_id_));
}

CertificateInfo::~CertificateInfo() {
  // @@protoc_insertion_point(destructor:resdb.CertificateInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CertificateInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete admin_public_key_;
  if (this != internal_default_instance()) delete public_key_;
}

void CertificateInfo::ArenaDtor(void* object) {
  CertificateInfo* _this = reinterpret_cast< CertificateInfo* >(object);
  (void)_this;
}
void CertificateInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CertificateInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CertificateInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:resdb.CertificateInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && admin_public_key_ != nullptr) {
    delete admin_public_key_;
  }
  admin_public_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && public_key_ != nullptr) {
    delete public_key_;
  }
  public_key_ = nullptr;
  node_id_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CertificateInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .resdb.KeyInfo admin_public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_admin_public_key(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .resdb.CertificateKey public_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_key(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 node_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CertificateInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:resdb.CertificateInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .resdb.KeyInfo admin_public_key = 1;
  if (this->has_admin_public_key()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::admin_public_key(this), target, stream);
  }

  // .resdb.CertificateKey public_key = 3;
  if (this->has_public_key()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::public_key(this), target, stream);
  }

  // int64 node_id = 4;
  if (this->node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_node_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:resdb.CertificateInfo)
  return target;
}

size_t CertificateInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:resdb.CertificateInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .resdb.KeyInfo admin_public_key = 1;
  if (this->has_admin_public_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *admin_public_key_);
  }

  // .resdb.CertificateKey public_key = 3;
  if (this->has_public_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *public_key_);
  }

  // int64 node_id = 4;
  if (this->node_id() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_node_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertificateInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:resdb.CertificateInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const CertificateInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CertificateInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:resdb.CertificateInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:resdb.CertificateInfo)
    MergeFrom(*source);
  }
}

void CertificateInfo::MergeFrom(const CertificateInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:resdb.CertificateInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_admin_public_key()) {
    _internal_mutable_admin_public_key()->::resdb::KeyInfo::MergeFrom(from._internal_admin_public_key());
  }
  if (from.has_public_key()) {
    _internal_mutable_public_key()->::resdb::CertificateKey::MergeFrom(from._internal_public_key());
  }
  if (from.node_id() != 0) {
    _internal_set_node_id(from._internal_node_id());
  }
}

void CertificateInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:resdb.CertificateInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CertificateInfo::CopyFrom(const CertificateInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:resdb.CertificateInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertificateInfo::IsInitialized() const {
  return true;
}

void CertificateInfo::InternalSwap(CertificateInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CertificateInfo, node_id_)
      + sizeof(CertificateInfo::node_id_)
      - PROTOBUF_FIELD_OFFSET(CertificateInfo, admin_public_key_)>(
          reinterpret_cast<char*>(&admin_public_key_),
          reinterpret_cast<char*>(&other->admin_public_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CertificateInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fsignature_5finfo_2eproto_getter, &descriptor_table_proto_2fsignature_5finfo_2eproto_once,
      file_level_metadata_proto_2fsignature_5finfo_2eproto[5]);
}

// ===================================================================

class SignatureKeyInfo::_Internal {
 public:
  static const ::resdb::KeyInfo& admin_public_key(const SignatureKeyInfo* msg);
  static const ::resdb::KeyInfo& private_key(const SignatureKeyInfo* msg);
};

const ::resdb::KeyInfo&
SignatureKeyInfo::_Internal::admin_public_key(const SignatureKeyInfo* msg) {
  return *msg->admin_public_key_;
}
const ::resdb::KeyInfo&
SignatureKeyInfo::_Internal::private_key(const SignatureKeyInfo* msg) {
  return *msg->private_key_;
}
SignatureKeyInfo::SignatureKeyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:resdb.SignatureKeyInfo)
}
SignatureKeyInfo::SignatureKeyInfo(const SignatureKeyInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_admin_public_key()) {
    admin_public_key_ = new ::resdb::KeyInfo(*from.admin_public_key_);
  } else {
    admin_public_key_ = nullptr;
  }
  if (from._internal_has_private_key()) {
    private_key_ = new ::resdb::KeyInfo(*from.private_key_);
  } else {
    private_key_ = nullptr;
  }
  node_id_ = from.node_id_;
  // @@protoc_insertion_point(copy_constructor:resdb.SignatureKeyInfo)
}

void SignatureKeyInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&admin_public_key_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&node_id_) -
    reinterpret_cast<char*>(&admin_public_key_)) + sizeof(node_id_));
}

SignatureKeyInfo::~SignatureKeyInfo() {
  // @@protoc_insertion_point(destructor:resdb.SignatureKeyInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SignatureKeyInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete admin_public_key_;
  if (this != internal_default_instance()) delete private_key_;
}

void SignatureKeyInfo::ArenaDtor(void* object) {
  SignatureKeyInfo* _this = reinterpret_cast< SignatureKeyInfo* >(object);
  (void)_this;
}
void SignatureKeyInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SignatureKeyInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SignatureKeyInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:resdb.SignatureKeyInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && admin_public_key_ != nullptr) {
    delete admin_public_key_;
  }
  admin_public_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && private_key_ != nullptr) {
    delete private_key_;
  }
  private_key_ = nullptr;
  node_id_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignatureKeyInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .resdb.KeyInfo admin_public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_admin_public_key(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .resdb.KeyInfo private_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_private_key(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 node_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SignatureKeyInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:resdb.SignatureKeyInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .resdb.KeyInfo admin_public_key = 1;
  if (this->has_admin_public_key()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::admin_public_key(this), target, stream);
  }

  // .resdb.KeyInfo private_key = 2;
  if (this->has_private_key()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::private_key(this), target, stream);
  }

  // int64 node_id = 3;
  if (this->node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_node_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:resdb.SignatureKeyInfo)
  return target;
}

size_t SignatureKeyInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:resdb.SignatureKeyInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .resdb.KeyInfo admin_public_key = 1;
  if (this->has_admin_public_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *admin_public_key_);
  }

  // .resdb.KeyInfo private_key = 2;
  if (this->has_private_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *private_key_);
  }

  // int64 node_id = 3;
  if (this->node_id() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_node_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SignatureKeyInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:resdb.SignatureKeyInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const SignatureKeyInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SignatureKeyInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:resdb.SignatureKeyInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:resdb.SignatureKeyInfo)
    MergeFrom(*source);
  }
}

void SignatureKeyInfo::MergeFrom(const SignatureKeyInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:resdb.SignatureKeyInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_admin_public_key()) {
    _internal_mutable_admin_public_key()->::resdb::KeyInfo::MergeFrom(from._internal_admin_public_key());
  }
  if (from.has_private_key()) {
    _internal_mutable_private_key()->::resdb::KeyInfo::MergeFrom(from._internal_private_key());
  }
  if (from.node_id() != 0) {
    _internal_set_node_id(from._internal_node_id());
  }
}

void SignatureKeyInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:resdb.SignatureKeyInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignatureKeyInfo::CopyFrom(const SignatureKeyInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:resdb.SignatureKeyInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignatureKeyInfo::IsInitialized() const {
  return true;
}

void SignatureKeyInfo::InternalSwap(SignatureKeyInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SignatureKeyInfo, node_id_)
      + sizeof(SignatureKeyInfo::node_id_)
      - PROTOBUF_FIELD_OFFSET(SignatureKeyInfo, admin_public_key_)>(
          reinterpret_cast<char*>(&admin_public_key_),
          reinterpret_cast<char*>(&other->admin_public_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SignatureKeyInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fsignature_5finfo_2eproto_getter, &descriptor_table_proto_2fsignature_5finfo_2eproto_once,
      file_level_metadata_proto_2fsignature_5finfo_2eproto[6]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace resdb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::resdb::SignatureInfo* Arena::CreateMaybeMessage< ::resdb::SignatureInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::resdb::SignatureInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::resdb::SecretKey* Arena::CreateMaybeMessage< ::resdb::SecretKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::resdb::SecretKey >(arena);
}
template<> PROTOBUF_NOINLINE ::resdb::KeyInfo* Arena::CreateMaybeMessage< ::resdb::KeyInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::resdb::KeyInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::resdb::CertificateKeyInfo* Arena::CreateMaybeMessage< ::resdb::CertificateKeyInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::resdb::CertificateKeyInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::resdb::CertificateKey* Arena::CreateMaybeMessage< ::resdb::CertificateKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::resdb::CertificateKey >(arena);
}
template<> PROTOBUF_NOINLINE ::resdb::CertificateInfo* Arena::CreateMaybeMessage< ::resdb::CertificateInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::resdb::CertificateInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::resdb::SignatureKeyInfo* Arena::CreateMaybeMessage< ::resdb::SignatureKeyInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::resdb::SignatureKeyInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
