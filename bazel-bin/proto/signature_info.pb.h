// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/signature_info.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fsignature_5finfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fsignature_5finfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fsignature_5finfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fsignature_5finfo_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fsignature_5finfo_2eproto;
namespace resdb {
class CertificateInfo;
struct CertificateInfoDefaultTypeInternal;
extern CertificateInfoDefaultTypeInternal _CertificateInfo_default_instance_;
class CertificateKey;
struct CertificateKeyDefaultTypeInternal;
extern CertificateKeyDefaultTypeInternal _CertificateKey_default_instance_;
class CertificateKeyInfo;
struct CertificateKeyInfoDefaultTypeInternal;
extern CertificateKeyInfoDefaultTypeInternal _CertificateKeyInfo_default_instance_;
class KeyInfo;
struct KeyInfoDefaultTypeInternal;
extern KeyInfoDefaultTypeInternal _KeyInfo_default_instance_;
class SecretKey;
struct SecretKeyDefaultTypeInternal;
extern SecretKeyDefaultTypeInternal _SecretKey_default_instance_;
class SignatureInfo;
struct SignatureInfoDefaultTypeInternal;
extern SignatureInfoDefaultTypeInternal _SignatureInfo_default_instance_;
class SignatureKeyInfo;
struct SignatureKeyInfoDefaultTypeInternal;
extern SignatureKeyInfoDefaultTypeInternal _SignatureKeyInfo_default_instance_;
}  // namespace resdb
PROTOBUF_NAMESPACE_OPEN
template<> ::resdb::CertificateInfo* Arena::CreateMaybeMessage<::resdb::CertificateInfo>(Arena*);
template<> ::resdb::CertificateKey* Arena::CreateMaybeMessage<::resdb::CertificateKey>(Arena*);
template<> ::resdb::CertificateKeyInfo* Arena::CreateMaybeMessage<::resdb::CertificateKeyInfo>(Arena*);
template<> ::resdb::KeyInfo* Arena::CreateMaybeMessage<::resdb::KeyInfo>(Arena*);
template<> ::resdb::SecretKey* Arena::CreateMaybeMessage<::resdb::SecretKey>(Arena*);
template<> ::resdb::SignatureInfo* Arena::CreateMaybeMessage<::resdb::SignatureInfo>(Arena*);
template<> ::resdb::SignatureKeyInfo* Arena::CreateMaybeMessage<::resdb::SignatureKeyInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace resdb {

enum SignatureInfo_HashType : int {
  SignatureInfo_HashType_NONE = 0,
  SignatureInfo_HashType_RSA = 1,
  SignatureInfo_HashType_ED25519 = 2,
  SignatureInfo_HashType_CMAC_AES = 3,
  SignatureInfo_HashType_SignatureInfo_HashType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SignatureInfo_HashType_SignatureInfo_HashType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SignatureInfo_HashType_IsValid(int value);
constexpr SignatureInfo_HashType SignatureInfo_HashType_HashType_MIN = SignatureInfo_HashType_NONE;
constexpr SignatureInfo_HashType SignatureInfo_HashType_HashType_MAX = SignatureInfo_HashType_CMAC_AES;
constexpr int SignatureInfo_HashType_HashType_ARRAYSIZE = SignatureInfo_HashType_HashType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignatureInfo_HashType_descriptor();
template<typename T>
inline const std::string& SignatureInfo_HashType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignatureInfo_HashType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignatureInfo_HashType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignatureInfo_HashType_descriptor(), enum_t_value);
}
inline bool SignatureInfo_HashType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignatureInfo_HashType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignatureInfo_HashType>(
    SignatureInfo_HashType_descriptor(), name, value);
}
enum CertificateKeyInfo_Type : int {
  CertificateKeyInfo_Type_REPLICA = 0,
  CertificateKeyInfo_Type_CLIENT = 1,
  CertificateKeyInfo_Type_CertificateKeyInfo_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CertificateKeyInfo_Type_CertificateKeyInfo_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CertificateKeyInfo_Type_IsValid(int value);
constexpr CertificateKeyInfo_Type CertificateKeyInfo_Type_Type_MIN = CertificateKeyInfo_Type_REPLICA;
constexpr CertificateKeyInfo_Type CertificateKeyInfo_Type_Type_MAX = CertificateKeyInfo_Type_CLIENT;
constexpr int CertificateKeyInfo_Type_Type_ARRAYSIZE = CertificateKeyInfo_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CertificateKeyInfo_Type_descriptor();
template<typename T>
inline const std::string& CertificateKeyInfo_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CertificateKeyInfo_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CertificateKeyInfo_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CertificateKeyInfo_Type_descriptor(), enum_t_value);
}
inline bool CertificateKeyInfo_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CertificateKeyInfo_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CertificateKeyInfo_Type>(
    CertificateKeyInfo_Type_descriptor(), name, value);
}
// ===================================================================

class SignatureInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.SignatureInfo) */ {
 public:
  inline SignatureInfo() : SignatureInfo(nullptr) {}
  ~SignatureInfo() override;
  explicit constexpr SignatureInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignatureInfo(const SignatureInfo& from);
  SignatureInfo(SignatureInfo&& from) noexcept
    : SignatureInfo() {
    *this = ::std::move(from);
  }

  inline SignatureInfo& operator=(const SignatureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignatureInfo& operator=(SignatureInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignatureInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignatureInfo* internal_default_instance() {
    return reinterpret_cast<const SignatureInfo*>(
               &_SignatureInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SignatureInfo& a, SignatureInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SignatureInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignatureInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignatureInfo* New() const final {
    return new SignatureInfo();
  }

  SignatureInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignatureInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignatureInfo& from);
  void MergeFrom(const SignatureInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignatureInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.SignatureInfo";
  }
  protected:
  explicit SignatureInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SignatureInfo_HashType HashType;
  static constexpr HashType NONE =
    SignatureInfo_HashType_NONE;
  static constexpr HashType RSA =
    SignatureInfo_HashType_RSA;
  static constexpr HashType ED25519 =
    SignatureInfo_HashType_ED25519;
  static constexpr HashType CMAC_AES =
    SignatureInfo_HashType_CMAC_AES;
  static inline bool HashType_IsValid(int value) {
    return SignatureInfo_HashType_IsValid(value);
  }
  static constexpr HashType HashType_MIN =
    SignatureInfo_HashType_HashType_MIN;
  static constexpr HashType HashType_MAX =
    SignatureInfo_HashType_HashType_MAX;
  static constexpr int HashType_ARRAYSIZE =
    SignatureInfo_HashType_HashType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HashType_descriptor() {
    return SignatureInfo_HashType_descriptor();
  }
  template<typename T>
  static inline const std::string& HashType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HashType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HashType_Name.");
    return SignatureInfo_HashType_Name(enum_t_value);
  }
  static inline bool HashType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HashType* value) {
    return SignatureInfo_HashType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 3,
    kNodeIdFieldNumber = 2,
    kHashTypeFieldNumber = 1,
  };
  // bytes signature = 3;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // int64 node_id = 2;
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int64 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .resdb.SignatureInfo.HashType hash_type = 1;
  void clear_hash_type();
  ::resdb::SignatureInfo_HashType hash_type() const;
  void set_hash_type(::resdb::SignatureInfo_HashType value);
  private:
  ::resdb::SignatureInfo_HashType _internal_hash_type() const;
  void _internal_set_hash_type(::resdb::SignatureInfo_HashType value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.SignatureInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::int64 node_id_;
  int hash_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fsignature_5finfo_2eproto;
};
// -------------------------------------------------------------------

class SecretKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.SecretKey) */ {
 public:
  inline SecretKey() : SecretKey(nullptr) {}
  ~SecretKey() override;
  explicit constexpr SecretKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecretKey(const SecretKey& from);
  SecretKey(SecretKey&& from) noexcept
    : SecretKey() {
    *this = ::std::move(from);
  }

  inline SecretKey& operator=(const SecretKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecretKey& operator=(SecretKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecretKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecretKey* internal_default_instance() {
    return reinterpret_cast<const SecretKey*>(
               &_SecretKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SecretKey& a, SecretKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SecretKey* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecretKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SecretKey* New() const final {
    return new SecretKey();
  }

  SecretKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SecretKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SecretKey& from);
  void MergeFrom(const SecretKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecretKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.SecretKey";
  }
  protected:
  explicit SecretKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kPrivateKeyFieldNumber = 2,
    kHashTypeFieldNumber = 3,
  };
  // bytes public_key = 1;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // bytes private_key = 2;
  void clear_private_key();
  const std::string& private_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_key();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // .resdb.SignatureInfo.HashType hash_type = 3;
  void clear_hash_type();
  ::resdb::SignatureInfo_HashType hash_type() const;
  void set_hash_type(::resdb::SignatureInfo_HashType value);
  private:
  ::resdb::SignatureInfo_HashType _internal_hash_type() const;
  void _internal_set_hash_type(::resdb::SignatureInfo_HashType value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.SecretKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
  int hash_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fsignature_5finfo_2eproto;
};
// -------------------------------------------------------------------

class KeyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.KeyInfo) */ {
 public:
  inline KeyInfo() : KeyInfo(nullptr) {}
  ~KeyInfo() override;
  explicit constexpr KeyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyInfo(const KeyInfo& from);
  KeyInfo(KeyInfo&& from) noexcept
    : KeyInfo() {
    *this = ::std::move(from);
  }

  inline KeyInfo& operator=(const KeyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyInfo& operator=(KeyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyInfo* internal_default_instance() {
    return reinterpret_cast<const KeyInfo*>(
               &_KeyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(KeyInfo& a, KeyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyInfo* New() const final {
    return new KeyInfo();
  }

  KeyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyInfo& from);
  void MergeFrom(const KeyInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.KeyInfo";
  }
  protected:
  explicit KeyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kHashTypeFieldNumber = 2,
  };
  // bytes key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .resdb.SignatureInfo.HashType hash_type = 2;
  void clear_hash_type();
  ::resdb::SignatureInfo_HashType hash_type() const;
  void set_hash_type(::resdb::SignatureInfo_HashType value);
  private:
  ::resdb::SignatureInfo_HashType _internal_hash_type() const;
  void _internal_set_hash_type(::resdb::SignatureInfo_HashType value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.KeyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int hash_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fsignature_5finfo_2eproto;
};
// -------------------------------------------------------------------

class CertificateKeyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.CertificateKeyInfo) */ {
 public:
  inline CertificateKeyInfo() : CertificateKeyInfo(nullptr) {}
  ~CertificateKeyInfo() override;
  explicit constexpr CertificateKeyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertificateKeyInfo(const CertificateKeyInfo& from);
  CertificateKeyInfo(CertificateKeyInfo&& from) noexcept
    : CertificateKeyInfo() {
    *this = ::std::move(from);
  }

  inline CertificateKeyInfo& operator=(const CertificateKeyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateKeyInfo& operator=(CertificateKeyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CertificateKeyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificateKeyInfo* internal_default_instance() {
    return reinterpret_cast<const CertificateKeyInfo*>(
               &_CertificateKeyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CertificateKeyInfo& a, CertificateKeyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateKeyInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificateKeyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CertificateKeyInfo* New() const final {
    return new CertificateKeyInfo();
  }

  CertificateKeyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CertificateKeyInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CertificateKeyInfo& from);
  void MergeFrom(const CertificateKeyInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CertificateKeyInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.CertificateKeyInfo";
  }
  protected:
  explicit CertificateKeyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CertificateKeyInfo_Type Type;
  static constexpr Type REPLICA =
    CertificateKeyInfo_Type_REPLICA;
  static constexpr Type CLIENT =
    CertificateKeyInfo_Type_CLIENT;
  static inline bool Type_IsValid(int value) {
    return CertificateKeyInfo_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    CertificateKeyInfo_Type_Type_MIN;
  static constexpr Type Type_MAX =
    CertificateKeyInfo_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    CertificateKeyInfo_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return CertificateKeyInfo_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return CertificateKeyInfo_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return CertificateKeyInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 4,
    kKeyFieldNumber = 1,
    kNodeIdFieldNumber = 2,
    kTypeFieldNumber = 3,
    kPortFieldNumber = 5,
  };
  // string ip = 4;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // .resdb.KeyInfo key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::resdb::KeyInfo& key() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::KeyInfo* release_key();
  ::resdb::KeyInfo* mutable_key();
  void set_allocated_key(::resdb::KeyInfo* key);
  private:
  const ::resdb::KeyInfo& _internal_key() const;
  ::resdb::KeyInfo* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::resdb::KeyInfo* key);
  ::resdb::KeyInfo* unsafe_arena_release_key();

  // int64 node_id = 2;
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int64 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .resdb.CertificateKeyInfo.Type type = 3;
  void clear_type();
  ::resdb::CertificateKeyInfo_Type type() const;
  void set_type(::resdb::CertificateKeyInfo_Type value);
  private:
  ::resdb::CertificateKeyInfo_Type _internal_type() const;
  void _internal_set_type(::resdb::CertificateKeyInfo_Type value);
  public:

  // int32 port = 5;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.CertificateKeyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::resdb::KeyInfo* key_;
  ::PROTOBUF_NAMESPACE_ID::int64 node_id_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fsignature_5finfo_2eproto;
};
// -------------------------------------------------------------------

class CertificateKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.CertificateKey) */ {
 public:
  inline CertificateKey() : CertificateKey(nullptr) {}
  ~CertificateKey() override;
  explicit constexpr CertificateKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertificateKey(const CertificateKey& from);
  CertificateKey(CertificateKey&& from) noexcept
    : CertificateKey() {
    *this = ::std::move(from);
  }

  inline CertificateKey& operator=(const CertificateKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateKey& operator=(CertificateKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CertificateKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificateKey* internal_default_instance() {
    return reinterpret_cast<const CertificateKey*>(
               &_CertificateKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CertificateKey& a, CertificateKey& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateKey* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificateKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CertificateKey* New() const final {
    return new CertificateKey();
  }

  CertificateKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CertificateKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CertificateKey& from);
  void MergeFrom(const CertificateKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CertificateKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.CertificateKey";
  }
  protected:
  explicit CertificateKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyInfoFieldNumber = 1,
    kCertificateFieldNumber = 2,
  };
  // .resdb.CertificateKeyInfo public_key_info = 1;
  bool has_public_key_info() const;
  private:
  bool _internal_has_public_key_info() const;
  public:
  void clear_public_key_info();
  const ::resdb::CertificateKeyInfo& public_key_info() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::CertificateKeyInfo* release_public_key_info();
  ::resdb::CertificateKeyInfo* mutable_public_key_info();
  void set_allocated_public_key_info(::resdb::CertificateKeyInfo* public_key_info);
  private:
  const ::resdb::CertificateKeyInfo& _internal_public_key_info() const;
  ::resdb::CertificateKeyInfo* _internal_mutable_public_key_info();
  public:
  void unsafe_arena_set_allocated_public_key_info(
      ::resdb::CertificateKeyInfo* public_key_info);
  ::resdb::CertificateKeyInfo* unsafe_arena_release_public_key_info();

  // .resdb.SignatureInfo certificate = 2;
  bool has_certificate() const;
  private:
  bool _internal_has_certificate() const;
  public:
  void clear_certificate();
  const ::resdb::SignatureInfo& certificate() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::SignatureInfo* release_certificate();
  ::resdb::SignatureInfo* mutable_certificate();
  void set_allocated_certificate(::resdb::SignatureInfo* certificate);
  private:
  const ::resdb::SignatureInfo& _internal_certificate() const;
  ::resdb::SignatureInfo* _internal_mutable_certificate();
  public:
  void unsafe_arena_set_allocated_certificate(
      ::resdb::SignatureInfo* certificate);
  ::resdb::SignatureInfo* unsafe_arena_release_certificate();

  // @@protoc_insertion_point(class_scope:resdb.CertificateKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::resdb::CertificateKeyInfo* public_key_info_;
  ::resdb::SignatureInfo* certificate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fsignature_5finfo_2eproto;
};
// -------------------------------------------------------------------

class CertificateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.CertificateInfo) */ {
 public:
  inline CertificateInfo() : CertificateInfo(nullptr) {}
  ~CertificateInfo() override;
  explicit constexpr CertificateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertificateInfo(const CertificateInfo& from);
  CertificateInfo(CertificateInfo&& from) noexcept
    : CertificateInfo() {
    *this = ::std::move(from);
  }

  inline CertificateInfo& operator=(const CertificateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateInfo& operator=(CertificateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CertificateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificateInfo* internal_default_instance() {
    return reinterpret_cast<const CertificateInfo*>(
               &_CertificateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CertificateInfo& a, CertificateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CertificateInfo* New() const final {
    return new CertificateInfo();
  }

  CertificateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CertificateInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CertificateInfo& from);
  void MergeFrom(const CertificateInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CertificateInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.CertificateInfo";
  }
  protected:
  explicit CertificateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdminPublicKeyFieldNumber = 1,
    kPublicKeyFieldNumber = 3,
    kNodeIdFieldNumber = 4,
  };
  // .resdb.KeyInfo admin_public_key = 1;
  bool has_admin_public_key() const;
  private:
  bool _internal_has_admin_public_key() const;
  public:
  void clear_admin_public_key();
  const ::resdb::KeyInfo& admin_public_key() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::KeyInfo* release_admin_public_key();
  ::resdb::KeyInfo* mutable_admin_public_key();
  void set_allocated_admin_public_key(::resdb::KeyInfo* admin_public_key);
  private:
  const ::resdb::KeyInfo& _internal_admin_public_key() const;
  ::resdb::KeyInfo* _internal_mutable_admin_public_key();
  public:
  void unsafe_arena_set_allocated_admin_public_key(
      ::resdb::KeyInfo* admin_public_key);
  ::resdb::KeyInfo* unsafe_arena_release_admin_public_key();

  // .resdb.CertificateKey public_key = 3;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::resdb::CertificateKey& public_key() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::CertificateKey* release_public_key();
  ::resdb::CertificateKey* mutable_public_key();
  void set_allocated_public_key(::resdb::CertificateKey* public_key);
  private:
  const ::resdb::CertificateKey& _internal_public_key() const;
  ::resdb::CertificateKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::resdb::CertificateKey* public_key);
  ::resdb::CertificateKey* unsafe_arena_release_public_key();

  // int64 node_id = 4;
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int64 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.CertificateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::resdb::KeyInfo* admin_public_key_;
  ::resdb::CertificateKey* public_key_;
  ::PROTOBUF_NAMESPACE_ID::int64 node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fsignature_5finfo_2eproto;
};
// -------------------------------------------------------------------

class SignatureKeyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resdb.SignatureKeyInfo) */ {
 public:
  inline SignatureKeyInfo() : SignatureKeyInfo(nullptr) {}
  ~SignatureKeyInfo() override;
  explicit constexpr SignatureKeyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignatureKeyInfo(const SignatureKeyInfo& from);
  SignatureKeyInfo(SignatureKeyInfo&& from) noexcept
    : SignatureKeyInfo() {
    *this = ::std::move(from);
  }

  inline SignatureKeyInfo& operator=(const SignatureKeyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignatureKeyInfo& operator=(SignatureKeyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignatureKeyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignatureKeyInfo* internal_default_instance() {
    return reinterpret_cast<const SignatureKeyInfo*>(
               &_SignatureKeyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SignatureKeyInfo& a, SignatureKeyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SignatureKeyInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignatureKeyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignatureKeyInfo* New() const final {
    return new SignatureKeyInfo();
  }

  SignatureKeyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignatureKeyInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignatureKeyInfo& from);
  void MergeFrom(const SignatureKeyInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignatureKeyInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resdb.SignatureKeyInfo";
  }
  protected:
  explicit SignatureKeyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdminPublicKeyFieldNumber = 1,
    kPrivateKeyFieldNumber = 2,
    kNodeIdFieldNumber = 3,
  };
  // .resdb.KeyInfo admin_public_key = 1;
  bool has_admin_public_key() const;
  private:
  bool _internal_has_admin_public_key() const;
  public:
  void clear_admin_public_key();
  const ::resdb::KeyInfo& admin_public_key() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::KeyInfo* release_admin_public_key();
  ::resdb::KeyInfo* mutable_admin_public_key();
  void set_allocated_admin_public_key(::resdb::KeyInfo* admin_public_key);
  private:
  const ::resdb::KeyInfo& _internal_admin_public_key() const;
  ::resdb::KeyInfo* _internal_mutable_admin_public_key();
  public:
  void unsafe_arena_set_allocated_admin_public_key(
      ::resdb::KeyInfo* admin_public_key);
  ::resdb::KeyInfo* unsafe_arena_release_admin_public_key();

  // .resdb.KeyInfo private_key = 2;
  bool has_private_key() const;
  private:
  bool _internal_has_private_key() const;
  public:
  void clear_private_key();
  const ::resdb::KeyInfo& private_key() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::resdb::KeyInfo* release_private_key();
  ::resdb::KeyInfo* mutable_private_key();
  void set_allocated_private_key(::resdb::KeyInfo* private_key);
  private:
  const ::resdb::KeyInfo& _internal_private_key() const;
  ::resdb::KeyInfo* _internal_mutable_private_key();
  public:
  void unsafe_arena_set_allocated_private_key(
      ::resdb::KeyInfo* private_key);
  ::resdb::KeyInfo* unsafe_arena_release_private_key();

  // int64 node_id = 3;
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int64 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:resdb.SignatureKeyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::resdb::KeyInfo* admin_public_key_;
  ::resdb::KeyInfo* private_key_;
  ::PROTOBUF_NAMESPACE_ID::int64 node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fsignature_5finfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SignatureInfo

// .resdb.SignatureInfo.HashType hash_type = 1;
inline void SignatureInfo::clear_hash_type() {
  hash_type_ = 0;
}
inline ::resdb::SignatureInfo_HashType SignatureInfo::_internal_hash_type() const {
  return static_cast< ::resdb::SignatureInfo_HashType >(hash_type_);
}
inline ::resdb::SignatureInfo_HashType SignatureInfo::hash_type() const {
  // @@protoc_insertion_point(field_get:resdb.SignatureInfo.hash_type)
  return _internal_hash_type();
}
inline void SignatureInfo::_internal_set_hash_type(::resdb::SignatureInfo_HashType value) {
  
  hash_type_ = value;
}
inline void SignatureInfo::set_hash_type(::resdb::SignatureInfo_HashType value) {
  _internal_set_hash_type(value);
  // @@protoc_insertion_point(field_set:resdb.SignatureInfo.hash_type)
}

// int64 node_id = 2;
inline void SignatureInfo::clear_node_id() {
  node_id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SignatureInfo::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SignatureInfo::node_id() const {
  // @@protoc_insertion_point(field_get:resdb.SignatureInfo.node_id)
  return _internal_node_id();
}
inline void SignatureInfo::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  node_id_ = value;
}
inline void SignatureInfo::set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:resdb.SignatureInfo.node_id)
}

// bytes signature = 3;
inline void SignatureInfo::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& SignatureInfo::signature() const {
  // @@protoc_insertion_point(field_get:resdb.SignatureInfo.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignatureInfo::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resdb.SignatureInfo.signature)
}
inline std::string* SignatureInfo::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:resdb.SignatureInfo.signature)
  return _internal_mutable_signature();
}
inline const std::string& SignatureInfo::_internal_signature() const {
  return signature_.Get();
}
inline void SignatureInfo::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignatureInfo::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignatureInfo::release_signature() {
  // @@protoc_insertion_point(field_release:resdb.SignatureInfo.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SignatureInfo::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:resdb.SignatureInfo.signature)
}

// -------------------------------------------------------------------

// SecretKey

// bytes public_key = 1;
inline void SecretKey::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& SecretKey::public_key() const {
  // @@protoc_insertion_point(field_get:resdb.SecretKey.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecretKey::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resdb.SecretKey.public_key)
}
inline std::string* SecretKey::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:resdb.SecretKey.public_key)
  return _internal_mutable_public_key();
}
inline const std::string& SecretKey::_internal_public_key() const {
  return public_key_.Get();
}
inline void SecretKey::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SecretKey::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SecretKey::release_public_key() {
  // @@protoc_insertion_point(field_release:resdb.SecretKey.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SecretKey::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:resdb.SecretKey.public_key)
}

// bytes private_key = 2;
inline void SecretKey::clear_private_key() {
  private_key_.ClearToEmpty();
}
inline const std::string& SecretKey::private_key() const {
  // @@protoc_insertion_point(field_get:resdb.SecretKey.private_key)
  return _internal_private_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecretKey::set_private_key(ArgT0&& arg0, ArgT... args) {
 
 private_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resdb.SecretKey.private_key)
}
inline std::string* SecretKey::mutable_private_key() {
  // @@protoc_insertion_point(field_mutable:resdb.SecretKey.private_key)
  return _internal_mutable_private_key();
}
inline const std::string& SecretKey::_internal_private_key() const {
  return private_key_.Get();
}
inline void SecretKey::_internal_set_private_key(const std::string& value) {
  
  private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SecretKey::_internal_mutable_private_key() {
  
  return private_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SecretKey::release_private_key() {
  // @@protoc_insertion_point(field_release:resdb.SecretKey.private_key)
  return private_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SecretKey::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    
  } else {
    
  }
  private_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:resdb.SecretKey.private_key)
}

// .resdb.SignatureInfo.HashType hash_type = 3;
inline void SecretKey::clear_hash_type() {
  hash_type_ = 0;
}
inline ::resdb::SignatureInfo_HashType SecretKey::_internal_hash_type() const {
  return static_cast< ::resdb::SignatureInfo_HashType >(hash_type_);
}
inline ::resdb::SignatureInfo_HashType SecretKey::hash_type() const {
  // @@protoc_insertion_point(field_get:resdb.SecretKey.hash_type)
  return _internal_hash_type();
}
inline void SecretKey::_internal_set_hash_type(::resdb::SignatureInfo_HashType value) {
  
  hash_type_ = value;
}
inline void SecretKey::set_hash_type(::resdb::SignatureInfo_HashType value) {
  _internal_set_hash_type(value);
  // @@protoc_insertion_point(field_set:resdb.SecretKey.hash_type)
}

// -------------------------------------------------------------------

// KeyInfo

// bytes key = 1;
inline void KeyInfo::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& KeyInfo::key() const {
  // @@protoc_insertion_point(field_get:resdb.KeyInfo.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyInfo::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resdb.KeyInfo.key)
}
inline std::string* KeyInfo::mutable_key() {
  // @@protoc_insertion_point(field_mutable:resdb.KeyInfo.key)
  return _internal_mutable_key();
}
inline const std::string& KeyInfo::_internal_key() const {
  return key_.Get();
}
inline void KeyInfo::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyInfo::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyInfo::release_key() {
  // @@protoc_insertion_point(field_release:resdb.KeyInfo.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyInfo::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:resdb.KeyInfo.key)
}

// .resdb.SignatureInfo.HashType hash_type = 2;
inline void KeyInfo::clear_hash_type() {
  hash_type_ = 0;
}
inline ::resdb::SignatureInfo_HashType KeyInfo::_internal_hash_type() const {
  return static_cast< ::resdb::SignatureInfo_HashType >(hash_type_);
}
inline ::resdb::SignatureInfo_HashType KeyInfo::hash_type() const {
  // @@protoc_insertion_point(field_get:resdb.KeyInfo.hash_type)
  return _internal_hash_type();
}
inline void KeyInfo::_internal_set_hash_type(::resdb::SignatureInfo_HashType value) {
  
  hash_type_ = value;
}
inline void KeyInfo::set_hash_type(::resdb::SignatureInfo_HashType value) {
  _internal_set_hash_type(value);
  // @@protoc_insertion_point(field_set:resdb.KeyInfo.hash_type)
}

// -------------------------------------------------------------------

// CertificateKeyInfo

// .resdb.KeyInfo key = 1;
inline bool CertificateKeyInfo::_internal_has_key() const {
  return this != internal_default_instance() && key_ != nullptr;
}
inline bool CertificateKeyInfo::has_key() const {
  return _internal_has_key();
}
inline void CertificateKeyInfo::clear_key() {
  if (GetArenaForAllocation() == nullptr && key_ != nullptr) {
    delete key_;
  }
  key_ = nullptr;
}
inline const ::resdb::KeyInfo& CertificateKeyInfo::_internal_key() const {
  const ::resdb::KeyInfo* p = key_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::KeyInfo&>(
      ::resdb::_KeyInfo_default_instance_);
}
inline const ::resdb::KeyInfo& CertificateKeyInfo::key() const {
  // @@protoc_insertion_point(field_get:resdb.CertificateKeyInfo.key)
  return _internal_key();
}
inline void CertificateKeyInfo::unsafe_arena_set_allocated_key(
    ::resdb::KeyInfo* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.CertificateKeyInfo.key)
}
inline ::resdb::KeyInfo* CertificateKeyInfo::release_key() {
  
  ::resdb::KeyInfo* temp = key_;
  key_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::KeyInfo* CertificateKeyInfo::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:resdb.CertificateKeyInfo.key)
  
  ::resdb::KeyInfo* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::resdb::KeyInfo* CertificateKeyInfo::_internal_mutable_key() {
  
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::KeyInfo>(GetArenaForAllocation());
    key_ = p;
  }
  return key_;
}
inline ::resdb::KeyInfo* CertificateKeyInfo::mutable_key() {
  // @@protoc_insertion_point(field_mutable:resdb.CertificateKeyInfo.key)
  return _internal_mutable_key();
}
inline void CertificateKeyInfo::set_allocated_key(::resdb::KeyInfo* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::resdb::KeyInfo>::GetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:resdb.CertificateKeyInfo.key)
}

// int64 node_id = 2;
inline void CertificateKeyInfo::clear_node_id() {
  node_id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CertificateKeyInfo::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CertificateKeyInfo::node_id() const {
  // @@protoc_insertion_point(field_get:resdb.CertificateKeyInfo.node_id)
  return _internal_node_id();
}
inline void CertificateKeyInfo::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  node_id_ = value;
}
inline void CertificateKeyInfo::set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:resdb.CertificateKeyInfo.node_id)
}

// .resdb.CertificateKeyInfo.Type type = 3;
inline void CertificateKeyInfo::clear_type() {
  type_ = 0;
}
inline ::resdb::CertificateKeyInfo_Type CertificateKeyInfo::_internal_type() const {
  return static_cast< ::resdb::CertificateKeyInfo_Type >(type_);
}
inline ::resdb::CertificateKeyInfo_Type CertificateKeyInfo::type() const {
  // @@protoc_insertion_point(field_get:resdb.CertificateKeyInfo.type)
  return _internal_type();
}
inline void CertificateKeyInfo::_internal_set_type(::resdb::CertificateKeyInfo_Type value) {
  
  type_ = value;
}
inline void CertificateKeyInfo::set_type(::resdb::CertificateKeyInfo_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:resdb.CertificateKeyInfo.type)
}

// string ip = 4;
inline void CertificateKeyInfo::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& CertificateKeyInfo::ip() const {
  // @@protoc_insertion_point(field_get:resdb.CertificateKeyInfo.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CertificateKeyInfo::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resdb.CertificateKeyInfo.ip)
}
inline std::string* CertificateKeyInfo::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:resdb.CertificateKeyInfo.ip)
  return _internal_mutable_ip();
}
inline const std::string& CertificateKeyInfo::_internal_ip() const {
  return ip_.Get();
}
inline void CertificateKeyInfo::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CertificateKeyInfo::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CertificateKeyInfo::release_ip() {
  // @@protoc_insertion_point(field_release:resdb.CertificateKeyInfo.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CertificateKeyInfo::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:resdb.CertificateKeyInfo.ip)
}

// int32 port = 5;
inline void CertificateKeyInfo::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CertificateKeyInfo::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CertificateKeyInfo::port() const {
  // @@protoc_insertion_point(field_get:resdb.CertificateKeyInfo.port)
  return _internal_port();
}
inline void CertificateKeyInfo::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void CertificateKeyInfo::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:resdb.CertificateKeyInfo.port)
}

// -------------------------------------------------------------------

// CertificateKey

// .resdb.CertificateKeyInfo public_key_info = 1;
inline bool CertificateKey::_internal_has_public_key_info() const {
  return this != internal_default_instance() && public_key_info_ != nullptr;
}
inline bool CertificateKey::has_public_key_info() const {
  return _internal_has_public_key_info();
}
inline void CertificateKey::clear_public_key_info() {
  if (GetArenaForAllocation() == nullptr && public_key_info_ != nullptr) {
    delete public_key_info_;
  }
  public_key_info_ = nullptr;
}
inline const ::resdb::CertificateKeyInfo& CertificateKey::_internal_public_key_info() const {
  const ::resdb::CertificateKeyInfo* p = public_key_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::CertificateKeyInfo&>(
      ::resdb::_CertificateKeyInfo_default_instance_);
}
inline const ::resdb::CertificateKeyInfo& CertificateKey::public_key_info() const {
  // @@protoc_insertion_point(field_get:resdb.CertificateKey.public_key_info)
  return _internal_public_key_info();
}
inline void CertificateKey::unsafe_arena_set_allocated_public_key_info(
    ::resdb::CertificateKeyInfo* public_key_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_info_);
  }
  public_key_info_ = public_key_info;
  if (public_key_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.CertificateKey.public_key_info)
}
inline ::resdb::CertificateKeyInfo* CertificateKey::release_public_key_info() {
  
  ::resdb::CertificateKeyInfo* temp = public_key_info_;
  public_key_info_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::CertificateKeyInfo* CertificateKey::unsafe_arena_release_public_key_info() {
  // @@protoc_insertion_point(field_release:resdb.CertificateKey.public_key_info)
  
  ::resdb::CertificateKeyInfo* temp = public_key_info_;
  public_key_info_ = nullptr;
  return temp;
}
inline ::resdb::CertificateKeyInfo* CertificateKey::_internal_mutable_public_key_info() {
  
  if (public_key_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::CertificateKeyInfo>(GetArenaForAllocation());
    public_key_info_ = p;
  }
  return public_key_info_;
}
inline ::resdb::CertificateKeyInfo* CertificateKey::mutable_public_key_info() {
  // @@protoc_insertion_point(field_mutable:resdb.CertificateKey.public_key_info)
  return _internal_mutable_public_key_info();
}
inline void CertificateKey::set_allocated_public_key_info(::resdb::CertificateKeyInfo* public_key_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete public_key_info_;
  }
  if (public_key_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::resdb::CertificateKeyInfo>::GetOwningArena(public_key_info);
    if (message_arena != submessage_arena) {
      public_key_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key_info, submessage_arena);
    }
    
  } else {
    
  }
  public_key_info_ = public_key_info;
  // @@protoc_insertion_point(field_set_allocated:resdb.CertificateKey.public_key_info)
}

// .resdb.SignatureInfo certificate = 2;
inline bool CertificateKey::_internal_has_certificate() const {
  return this != internal_default_instance() && certificate_ != nullptr;
}
inline bool CertificateKey::has_certificate() const {
  return _internal_has_certificate();
}
inline void CertificateKey::clear_certificate() {
  if (GetArenaForAllocation() == nullptr && certificate_ != nullptr) {
    delete certificate_;
  }
  certificate_ = nullptr;
}
inline const ::resdb::SignatureInfo& CertificateKey::_internal_certificate() const {
  const ::resdb::SignatureInfo* p = certificate_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::SignatureInfo&>(
      ::resdb::_SignatureInfo_default_instance_);
}
inline const ::resdb::SignatureInfo& CertificateKey::certificate() const {
  // @@protoc_insertion_point(field_get:resdb.CertificateKey.certificate)
  return _internal_certificate();
}
inline void CertificateKey::unsafe_arena_set_allocated_certificate(
    ::resdb::SignatureInfo* certificate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(certificate_);
  }
  certificate_ = certificate;
  if (certificate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.CertificateKey.certificate)
}
inline ::resdb::SignatureInfo* CertificateKey::release_certificate() {
  
  ::resdb::SignatureInfo* temp = certificate_;
  certificate_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::SignatureInfo* CertificateKey::unsafe_arena_release_certificate() {
  // @@protoc_insertion_point(field_release:resdb.CertificateKey.certificate)
  
  ::resdb::SignatureInfo* temp = certificate_;
  certificate_ = nullptr;
  return temp;
}
inline ::resdb::SignatureInfo* CertificateKey::_internal_mutable_certificate() {
  
  if (certificate_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::SignatureInfo>(GetArenaForAllocation());
    certificate_ = p;
  }
  return certificate_;
}
inline ::resdb::SignatureInfo* CertificateKey::mutable_certificate() {
  // @@protoc_insertion_point(field_mutable:resdb.CertificateKey.certificate)
  return _internal_mutable_certificate();
}
inline void CertificateKey::set_allocated_certificate(::resdb::SignatureInfo* certificate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete certificate_;
  }
  if (certificate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::resdb::SignatureInfo>::GetOwningArena(certificate);
    if (message_arena != submessage_arena) {
      certificate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, certificate, submessage_arena);
    }
    
  } else {
    
  }
  certificate_ = certificate;
  // @@protoc_insertion_point(field_set_allocated:resdb.CertificateKey.certificate)
}

// -------------------------------------------------------------------

// CertificateInfo

// .resdb.KeyInfo admin_public_key = 1;
inline bool CertificateInfo::_internal_has_admin_public_key() const {
  return this != internal_default_instance() && admin_public_key_ != nullptr;
}
inline bool CertificateInfo::has_admin_public_key() const {
  return _internal_has_admin_public_key();
}
inline void CertificateInfo::clear_admin_public_key() {
  if (GetArenaForAllocation() == nullptr && admin_public_key_ != nullptr) {
    delete admin_public_key_;
  }
  admin_public_key_ = nullptr;
}
inline const ::resdb::KeyInfo& CertificateInfo::_internal_admin_public_key() const {
  const ::resdb::KeyInfo* p = admin_public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::KeyInfo&>(
      ::resdb::_KeyInfo_default_instance_);
}
inline const ::resdb::KeyInfo& CertificateInfo::admin_public_key() const {
  // @@protoc_insertion_point(field_get:resdb.CertificateInfo.admin_public_key)
  return _internal_admin_public_key();
}
inline void CertificateInfo::unsafe_arena_set_allocated_admin_public_key(
    ::resdb::KeyInfo* admin_public_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(admin_public_key_);
  }
  admin_public_key_ = admin_public_key;
  if (admin_public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.CertificateInfo.admin_public_key)
}
inline ::resdb::KeyInfo* CertificateInfo::release_admin_public_key() {
  
  ::resdb::KeyInfo* temp = admin_public_key_;
  admin_public_key_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::KeyInfo* CertificateInfo::unsafe_arena_release_admin_public_key() {
  // @@protoc_insertion_point(field_release:resdb.CertificateInfo.admin_public_key)
  
  ::resdb::KeyInfo* temp = admin_public_key_;
  admin_public_key_ = nullptr;
  return temp;
}
inline ::resdb::KeyInfo* CertificateInfo::_internal_mutable_admin_public_key() {
  
  if (admin_public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::KeyInfo>(GetArenaForAllocation());
    admin_public_key_ = p;
  }
  return admin_public_key_;
}
inline ::resdb::KeyInfo* CertificateInfo::mutable_admin_public_key() {
  // @@protoc_insertion_point(field_mutable:resdb.CertificateInfo.admin_public_key)
  return _internal_mutable_admin_public_key();
}
inline void CertificateInfo::set_allocated_admin_public_key(::resdb::KeyInfo* admin_public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete admin_public_key_;
  }
  if (admin_public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::resdb::KeyInfo>::GetOwningArena(admin_public_key);
    if (message_arena != submessage_arena) {
      admin_public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, admin_public_key, submessage_arena);
    }
    
  } else {
    
  }
  admin_public_key_ = admin_public_key;
  // @@protoc_insertion_point(field_set_allocated:resdb.CertificateInfo.admin_public_key)
}

// .resdb.CertificateKey public_key = 3;
inline bool CertificateInfo::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool CertificateInfo::has_public_key() const {
  return _internal_has_public_key();
}
inline void CertificateInfo::clear_public_key() {
  if (GetArenaForAllocation() == nullptr && public_key_ != nullptr) {
    delete public_key_;
  }
  public_key_ = nullptr;
}
inline const ::resdb::CertificateKey& CertificateInfo::_internal_public_key() const {
  const ::resdb::CertificateKey* p = public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::CertificateKey&>(
      ::resdb::_CertificateKey_default_instance_);
}
inline const ::resdb::CertificateKey& CertificateInfo::public_key() const {
  // @@protoc_insertion_point(field_get:resdb.CertificateInfo.public_key)
  return _internal_public_key();
}
inline void CertificateInfo::unsafe_arena_set_allocated_public_key(
    ::resdb::CertificateKey* public_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.CertificateInfo.public_key)
}
inline ::resdb::CertificateKey* CertificateInfo::release_public_key() {
  
  ::resdb::CertificateKey* temp = public_key_;
  public_key_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::CertificateKey* CertificateInfo::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:resdb.CertificateInfo.public_key)
  
  ::resdb::CertificateKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::resdb::CertificateKey* CertificateInfo::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::CertificateKey>(GetArenaForAllocation());
    public_key_ = p;
  }
  return public_key_;
}
inline ::resdb::CertificateKey* CertificateInfo::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:resdb.CertificateInfo.public_key)
  return _internal_mutable_public_key();
}
inline void CertificateInfo::set_allocated_public_key(::resdb::CertificateKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete public_key_;
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::resdb::CertificateKey>::GetOwningArena(public_key);
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:resdb.CertificateInfo.public_key)
}

// int64 node_id = 4;
inline void CertificateInfo::clear_node_id() {
  node_id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CertificateInfo::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CertificateInfo::node_id() const {
  // @@protoc_insertion_point(field_get:resdb.CertificateInfo.node_id)
  return _internal_node_id();
}
inline void CertificateInfo::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  node_id_ = value;
}
inline void CertificateInfo::set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:resdb.CertificateInfo.node_id)
}

// -------------------------------------------------------------------

// SignatureKeyInfo

// .resdb.KeyInfo admin_public_key = 1;
inline bool SignatureKeyInfo::_internal_has_admin_public_key() const {
  return this != internal_default_instance() && admin_public_key_ != nullptr;
}
inline bool SignatureKeyInfo::has_admin_public_key() const {
  return _internal_has_admin_public_key();
}
inline void SignatureKeyInfo::clear_admin_public_key() {
  if (GetArenaForAllocation() == nullptr && admin_public_key_ != nullptr) {
    delete admin_public_key_;
  }
  admin_public_key_ = nullptr;
}
inline const ::resdb::KeyInfo& SignatureKeyInfo::_internal_admin_public_key() const {
  const ::resdb::KeyInfo* p = admin_public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::KeyInfo&>(
      ::resdb::_KeyInfo_default_instance_);
}
inline const ::resdb::KeyInfo& SignatureKeyInfo::admin_public_key() const {
  // @@protoc_insertion_point(field_get:resdb.SignatureKeyInfo.admin_public_key)
  return _internal_admin_public_key();
}
inline void SignatureKeyInfo::unsafe_arena_set_allocated_admin_public_key(
    ::resdb::KeyInfo* admin_public_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(admin_public_key_);
  }
  admin_public_key_ = admin_public_key;
  if (admin_public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.SignatureKeyInfo.admin_public_key)
}
inline ::resdb::KeyInfo* SignatureKeyInfo::release_admin_public_key() {
  
  ::resdb::KeyInfo* temp = admin_public_key_;
  admin_public_key_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::KeyInfo* SignatureKeyInfo::unsafe_arena_release_admin_public_key() {
  // @@protoc_insertion_point(field_release:resdb.SignatureKeyInfo.admin_public_key)
  
  ::resdb::KeyInfo* temp = admin_public_key_;
  admin_public_key_ = nullptr;
  return temp;
}
inline ::resdb::KeyInfo* SignatureKeyInfo::_internal_mutable_admin_public_key() {
  
  if (admin_public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::KeyInfo>(GetArenaForAllocation());
    admin_public_key_ = p;
  }
  return admin_public_key_;
}
inline ::resdb::KeyInfo* SignatureKeyInfo::mutable_admin_public_key() {
  // @@protoc_insertion_point(field_mutable:resdb.SignatureKeyInfo.admin_public_key)
  return _internal_mutable_admin_public_key();
}
inline void SignatureKeyInfo::set_allocated_admin_public_key(::resdb::KeyInfo* admin_public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete admin_public_key_;
  }
  if (admin_public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::resdb::KeyInfo>::GetOwningArena(admin_public_key);
    if (message_arena != submessage_arena) {
      admin_public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, admin_public_key, submessage_arena);
    }
    
  } else {
    
  }
  admin_public_key_ = admin_public_key;
  // @@protoc_insertion_point(field_set_allocated:resdb.SignatureKeyInfo.admin_public_key)
}

// .resdb.KeyInfo private_key = 2;
inline bool SignatureKeyInfo::_internal_has_private_key() const {
  return this != internal_default_instance() && private_key_ != nullptr;
}
inline bool SignatureKeyInfo::has_private_key() const {
  return _internal_has_private_key();
}
inline void SignatureKeyInfo::clear_private_key() {
  if (GetArenaForAllocation() == nullptr && private_key_ != nullptr) {
    delete private_key_;
  }
  private_key_ = nullptr;
}
inline const ::resdb::KeyInfo& SignatureKeyInfo::_internal_private_key() const {
  const ::resdb::KeyInfo* p = private_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::resdb::KeyInfo&>(
      ::resdb::_KeyInfo_default_instance_);
}
inline const ::resdb::KeyInfo& SignatureKeyInfo::private_key() const {
  // @@protoc_insertion_point(field_get:resdb.SignatureKeyInfo.private_key)
  return _internal_private_key();
}
inline void SignatureKeyInfo::unsafe_arena_set_allocated_private_key(
    ::resdb::KeyInfo* private_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(private_key_);
  }
  private_key_ = private_key;
  if (private_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resdb.SignatureKeyInfo.private_key)
}
inline ::resdb::KeyInfo* SignatureKeyInfo::release_private_key() {
  
  ::resdb::KeyInfo* temp = private_key_;
  private_key_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::resdb::KeyInfo* SignatureKeyInfo::unsafe_arena_release_private_key() {
  // @@protoc_insertion_point(field_release:resdb.SignatureKeyInfo.private_key)
  
  ::resdb::KeyInfo* temp = private_key_;
  private_key_ = nullptr;
  return temp;
}
inline ::resdb::KeyInfo* SignatureKeyInfo::_internal_mutable_private_key() {
  
  if (private_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::resdb::KeyInfo>(GetArenaForAllocation());
    private_key_ = p;
  }
  return private_key_;
}
inline ::resdb::KeyInfo* SignatureKeyInfo::mutable_private_key() {
  // @@protoc_insertion_point(field_mutable:resdb.SignatureKeyInfo.private_key)
  return _internal_mutable_private_key();
}
inline void SignatureKeyInfo::set_allocated_private_key(::resdb::KeyInfo* private_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete private_key_;
  }
  if (private_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::resdb::KeyInfo>::GetOwningArena(private_key);
    if (message_arena != submessage_arena) {
      private_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, private_key, submessage_arena);
    }
    
  } else {
    
  }
  private_key_ = private_key;
  // @@protoc_insertion_point(field_set_allocated:resdb.SignatureKeyInfo.private_key)
}

// int64 node_id = 3;
inline void SignatureKeyInfo::clear_node_id() {
  node_id_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SignatureKeyInfo::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SignatureKeyInfo::node_id() const {
  // @@protoc_insertion_point(field_get:resdb.SignatureKeyInfo.node_id)
  return _internal_node_id();
}
inline void SignatureKeyInfo::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  node_id_ = value;
}
inline void SignatureKeyInfo::set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:resdb.SignatureKeyInfo.node_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace resdb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::resdb::SignatureInfo_HashType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resdb::SignatureInfo_HashType>() {
  return ::resdb::SignatureInfo_HashType_descriptor();
}
template <> struct is_proto_enum< ::resdb::CertificateKeyInfo_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resdb::CertificateKeyInfo_Type>() {
  return ::resdb::CertificateKeyInfo_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fsignature_5finfo_2eproto
